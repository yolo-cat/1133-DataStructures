<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/Todo.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/Todo.md" />
              <option name="originalContent" value="# 0729-HeapApplication 專案任務清單&#10;&#10;## 1. 類別與資料結構&#10;- [x] 實作 Item 類別（含生產日期時間、物品編號、Comparable）&#10;- [x] 實作 MinHeapBuffer 類別（最小堆、同步、容量控制）&#10;- [x] 實作 Producer 執行緒類別&#10;- [x] 實作 Consumer 執行緒類別&#10;- [x] 優化 Item 編號生成（100~999隨機數字）&#10;- [x] 驗證 MinHeapBuffer 的 Min-Heap 效能（O(log n) 插入/取出）&#10;- [x] 實作 Machine 執行緒類別（每 0.24 秒從 buffer 取出最小編號物品進行處理，buffer 空則等待）&#10;- [x] 實作 EnhancedConsumer 執行緒類別（每 0.24 秒從 buffer 取出最小編號物品，buffer 空則等待）&#10;&#10;## 2. 執行緒協調&#10;- [x] 緩衝區操作同步（wait/notify 或 Condition）&#10;- [x] 生產者-消費者協調邏輯&#10;- [ ] 機台與消費者執行緒協調邏輯（確保機台與消費者分別正確處理/消費最小編號物品）&#10;&#10;## 3. GUI 介面&#10;- [x] 設計 GUI 介面（開始生產按鈕、buffer 大小設定）&#10;- [x] 顯示 buffer 狀態與物品流動&#10;- [x] 顯示輸出分為四個區域：生產者、buffer 狀態、機台、消費者，以便清楚區分各部分功能&#10;- [ ] 機台區域顯示：顯示機台正在處理的物品編號&#10;- [ ] 消費者區域顯示：顯示消費者取出的物品編號&#10;&#10;## 4. 主程式整合&#10;- [x] 整合主程式，啟動 Producer/Consumer 執行緒&#10;- [x] 連接 GUI 與核心邏輯&#10;- [ ] 整合 Machine 與 EnhancedConsumer 執行緒的啟動與協調&#10;&#10;## 5. Min-Heap 效能優化與驗證&#10;- [ ] 實作效能測試：比較線性搜尋 vs Min-Heap 效能&#10;- [ ] 測試大量資料下的處理效能（不同 buffer 大小）&#10;- [ ] 驗證最小編號物品挑選的正確性&#10;- [ ] 測量系統單位時間處理物品數量&#10;- [ ] 效能基準測試報告&#10;&#10;## 6. 測試與優化&#10;- [ ] 測試各元件功能與同步正確性&#10;- [ ] 測試 GUI 操作與顯示&#10;- [ ] 參數可調整（生產/消費速度、buffer 大小）&#10;- [ ] 壓力測試：高頻率生產消費場景&#10;&#10;## 7. 演算法驗證&#10;- [ ] 驗證 Min-Heap 始終取出最小編號物品&#10;- [ ] 測試隨機編號生成的分布性&#10;- [ ] 確認處理順序符合機台優先處理最小編號的需求&#10;&#10;## 8. 文件&#10;- [ ] 完善程式註解與使用說明&#10;- [ ] 更新設計與需求文件&#10;- [ ] 效能分析報告（O(n) vs O(log n) 比較）&#10;" />
              <option name="updatedContent" value="# 0729-HeapApplication 專案任務清單&#10;&#10;## 1. 類別與資料結構&#10;- [x] 實作 Item 類別（含生產日期時間、物品編號、Comparable）&#10;- [x] 實作 MinHeapBuffer 類別（最小堆、同步、容量控制）&#10;- [x] 實作 Producer 執行緒類別&#10;- [x] 實作 Consumer 執行緒類別&#10;- [x] 優化 Item 編號生成（100~999隨機數字）&#10;- [x] 驗證 MinHeapBuffer 的 Min-Heap 效能（O(log n) 插入/取出）&#10;- [x] 實作 Machine 執行緒類別（每 0.24 秒從 buffer 取出最小編號物品進行處理，buffer 空則等待）&#10;- [x] 實作 EnhancedConsumer 執行緒類別（每 0.24 秒從 buffer 取出最小編號物品，buffer 空則等待）&#10;&#10;## 2. 執行緒協調&#10;- [x] 緩衝區操作同步（wait/notify 或 Condition）&#10;- [x] 生產者-消費者協調邏輯&#10;- [ ] 機台與消費者執行緒協調邏輯（確保機台與消費者分別正確處理/消費最小編號物品）&#10;    - [ ] 設計「機台暫存區」(如 processedQueue) 或於 Item 增加狀態欄位&#10;    - [ ] 機台執行緒從 buffer 取物品，處理後放入暫存區或標記狀態&#10;    - [ ] 消費者執行緒僅從暫存區消費（或僅消費已處理物品）&#10;    - [ ] 機台-消費者間同步協調（wait/notify）&#10;&#10;## 3. GUI 介面&#10;- [x] 設計 GUI 介面（開始生產按鈕、buffer 大小設定）&#10;- [x] 顯示 buffer 狀態與物品流動&#10;- [x] 顯示輸出分為四個區域：生產者、buffer 狀態、機台、消費者，以便清楚區分各部分功能&#10;- [ ] 機台區域顯示：顯示機台正在處理的物品編號&#10;- [ ] 消費者區域顯示：顯示消費者取出的物品編號&#10;&#10;## 4. 主程式整合&#10;- [x] 整合主程式，啟動 Producer/Consumer 執行緒&#10;- [x] 連接 GUI 與核心邏輯&#10;- [ ] 整合 Machine 與 EnhancedConsumer 執行緒的啟動與協調&#10;&#10;## 5. Min-Heap 效能優化與驗證&#10;- [ ] 實作效能測試：比較線性搜尋 vs Min-Heap 效能&#10;- [ ] 測試大量資料下的處理效能（不同 buffer 大小）&#10;- [ ] 驗證最小編號物品挑選的正確性&#10;- [ ] 測量系統單位時間處理物品數量&#10;- [ ] 效能基準測試報告&#10;&#10;## 6. 測試與優化&#10;- [ ] 測試各元件功能與同步正確性&#10;- [ ] 測試 GUI 操作與顯示&#10;- [ ] 參數可調整（生產/消費速度、buffer 大小）&#10;- [ ] 壓力測試：高頻率生產消費場景&#10;&#10;## 7. 演算法驗證&#10;- [ ] 驗證 Min-Heap 始終取出最小編號物品&#10;- [ ] 測試隨機編號生成的分布性&#10;- [ ] 確認處理順序符合機台優先處理最小編號的需求&#10;&#10;## 8. 文件&#10;- [ ] 完善程式註解與使用說明&#10;- [ ] 更新設計與需求文件&#10;- [ ] 效能分析報告（O(n) vs O(log n) 比較）" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/EnhancedConsumer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/EnhancedConsumer.java" />
              <option name="originalContent" value="public class EnhancedConsumer extends Thread {&#10;    private final MinHeapBuffer buffer;&#10;    private final int consumeIntervalMs;&#10;    private final ProducerConsumerGUI gui;&#10;    private volatile boolean running = true;&#10;&#10;    public EnhancedConsumer(MinHeapBuffer buffer, int consumeIntervalMs, ProducerConsumerGUI gui) {&#10;        this.buffer = buffer;&#10;        this.consumeIntervalMs = consumeIntervalMs;&#10;        this.gui = gui;&#10;    }&#10;&#10;    public void stopConsumer() {&#10;        running = false;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        try {&#10;            while (running) {&#10;                Item item = buffer.take();&#10;                String message = &quot;消費: &quot; + item;&#10;                System.out.println(message);&#10;                if (gui != null) {&#10;                    gui.appendToConsumer(message);&#10;                }&#10;                Thread.sleep(consumeIntervalMs);&#10;            }&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="public class EnhancedConsumer extends Thread {&#10;    private final ProcessedQueue processedQueue;&#10;    private final int consumeIntervalMs;&#10;    private final ProducerConsumerGUI gui;&#10;    private volatile boolean running = true;&#10;&#10;    public EnhancedConsumer(ProcessedQueue processedQueue, int consumeIntervalMs, ProducerConsumerGUI gui) {&#10;        this.processedQueue = processedQueue;&#10;        this.consumeIntervalMs = consumeIntervalMs;&#10;        this.gui = gui;&#10;    }&#10;&#10;    public void stopConsumer() {&#10;        running = false;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        try {&#10;            while (running) {&#10;                Item item = processedQueue.take();&#10;                String message = &quot;消費: &quot; + item;&#10;                System.out.println(message);&#10;                if (gui != null) {&#10;                    gui.appendToConsumer(message);&#10;                }&#10;                Thread.sleep(consumeIntervalMs);&#10;            }&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/FlowVisualizationPanel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/FlowVisualizationPanel.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.geom.*;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CopyOnWriteArrayList;&#10;&#10;public class FlowVisualizationPanel extends JPanel {&#10;    private List&lt;AnimatedItem&gt; animatedItems = new CopyOnWriteArrayList&lt;&gt;();&#10;    private Timer animationTimer;&#10;&#10;    // 流程中的各個區域位置&#10;    private static final int PRODUCER_X = 50;&#10;    private static final int BUFFER_X = 200;&#10;    private static final int MACHINE_X = 350;&#10;    private static final int CONSUMER_X = 500;&#10;    private static final int CENTER_Y = 80;&#10;    private static final int ITEM_SIZE = 20;&#10;&#10;    public FlowVisualizationPanel() {&#10;        setPreferredSize(new Dimension(600, 160));&#10;        setBackground(new Color(240, 240, 240));&#10;        setBorder(BorderFactory.createTitledBorder(&quot; 物品流動動畫 (Item Flow Animation)&quot;));&#10;&#10;        // 啟動動畫定時器&#10;        animationTimer = new Timer(50, e -&gt; {&#10;            updateAnimations();&#10;            repaint();&#10;        });&#10;        animationTimer.start();&#10;    }&#10;&#10;    private void updateAnimations() {&#10;        // 移除已完成的動畫物品&#10;        animatedItems.removeIf(item -&gt; item.isFinished());&#10;&#10;        // 更新所有動畫物品的位置&#10;        for (AnimatedItem item : animatedItems) {&#10;            item.update();&#10;        }&#10;    }&#10;&#10;    public void addProducerToBuffer(Item item) {&#10;        AnimatedItem animItem = new AnimatedItem(item, PRODUCER_X, CENTER_Y, BUFFER_X, CENTER_Y, Color.GREEN);&#10;        animatedItems.add(animItem);&#10;    }&#10;&#10;    public void addBufferToMachine(Item item) {&#10;        AnimatedItem animItem = new AnimatedItem(item, BUFFER_X, CENTER_Y, MACHINE_X, CENTER_Y, Color.BLUE);&#10;        animatedItems.add(animItem);&#10;    }&#10;&#10;    public void addMachineToConsumer(Item item) {&#10;        AnimatedItem animItem = new AnimatedItem(item, MACHINE_X, CENTER_Y, CONSUMER_X, CENTER_Y, Color.RED);&#10;        animatedItems.add(animItem);&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        Graphics2D g2d = (Graphics2D) g;&#10;        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;        // 繪製流程圖框架&#10;        drawFlowFramework(g2d);&#10;&#10;        // 繪製動畫中的物品&#10;        for (AnimatedItem item : animatedItems) {&#10;            item.draw(g2d);&#10;        }&#10;    }&#10;&#10;    private void drawFlowFramework(Graphics2D g2d) {&#10;        // 繪製各個區域的框架&#10;        drawStationBox(g2d, PRODUCER_X - 25, CENTER_Y - 25, &quot; 生產者&quot;, Color.GREEN);&#10;        drawStationBox(g2d, BUFFER_X - 25, CENTER_Y - 25, &quot; 緩衝區&quot;, Color.ORANGE);&#10;        drawStationBox(g2d, MACHINE_X - 25, CENTER_Y - 25, &quot;⚙️ 機台&quot;, Color.BLUE);&#10;        drawStationBox(g2d, CONSUMER_X - 25, CENTER_Y - 25, &quot; 消費者&quot;, Color.RED);&#10;&#10;        // 繪製箭頭連接線&#10;        drawArrow(g2d, PRODUCER_X + 25, CENTER_Y, BUFFER_X - 25, CENTER_Y);&#10;        drawArrow(g2d, BUFFER_X + 25, CENTER_Y, MACHINE_X - 25, CENTER_Y);&#10;        drawArrow(g2d, MACHINE_X + 25, CENTER_Y, CONSUMER_X - 25, CENTER_Y);&#10;&#10;        // 添加說明文字&#10;        g2d.setColor(Color.BLACK);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 10));&#10;        g2d.drawString(&quot;0.2s&quot;, PRODUCER_X + 30, CENTER_Y - 10);&#10;        g2d.drawString(&quot;0.24s&quot;, BUFFER_X + 30, CENTER_Y - 10);&#10;        g2d.drawString(&quot;0.24s&quot;, MACHINE_X + 30, CENTER_Y - 10);&#10;    }&#10;&#10;    private void drawStationBox(Graphics2D g2d, int x, int y, String label, Color color) {&#10;        g2d.setColor(color.brighter().brighter());&#10;        g2d.fillRoundRect(x, y, 50, 50, 10, 10);&#10;        g2d.setColor(color);&#10;        g2d.setStroke(new BasicStroke(2));&#10;        g2d.drawRoundRect(x, y, 50, 50, 10, 10);&#10;&#10;        g2d.setColor(Color.BLACK);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 8));&#10;        FontMetrics fm = g2d.getFontMetrics();&#10;        int textWidth = fm.stringWidth(label);&#10;        g2d.drawString(label, x + (50 - textWidth) / 2, y + 60);&#10;    }&#10;&#10;    private void drawArrow(Graphics2D g2d, int x1, int y1, int x2, int y2) {&#10;        g2d.setColor(Color.GRAY);&#10;        g2d.setStroke(new BasicStroke(2));&#10;        g2d.drawLine(x1, y1, x2, y2);&#10;&#10;        // 繪製箭頭頭部&#10;        int arrowLength = 8;&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#10;&#10;        int arrowX1 = (int) (x2 - arrowLength * Math.cos(angle - Math.PI / 6));&#10;        int arrowY1 = (int) (y2 - arrowLength * Math.sin(angle - Math.PI / 6));&#10;        int arrowX2 = (int) (x2 - arrowLength * Math.cos(angle + Math.PI / 6));&#10;        int arrowY2 = (int) (y2 - arrowLength * Math.sin(angle + Math.PI / 6));&#10;&#10;        g2d.drawLine(x2, y2, arrowX1, arrowY1);&#10;        g2d.drawLine(x2, y2, arrowX2, arrowY2);&#10;    }&#10;&#10;    // 內部類：動畫物品&#10;    private static class AnimatedItem {&#10;        private Item item;&#10;        private double currentX, currentY;&#10;        private double targetX, targetY;&#10;        private double startX, startY;&#10;        private Color color;&#10;        private double progress = 0.0;&#10;        private static final double ANIMATION_SPEED = 0.02;&#10;&#10;        public AnimatedItem(Item item, double startX, double startY, double targetX, double targetY, Color color) {&#10;            this.item = item;&#10;            this.startX = startX;&#10;            this.startY = startY;&#10;            this.currentX = startX;&#10;            this.currentY = startY;&#10;            this.targetX = targetX;&#10;            this.targetY = targetY;&#10;            this.color = color;&#10;        }&#10;&#10;        public void update() {&#10;            if (progress &lt; 1.0) {&#10;                progress += ANIMATION_SPEED;&#10;                if (progress &gt; 1.0) progress = 1.0;&#10;&#10;                // 使用緩動函數讓動畫更平滑&#10;                double easeProgress = easeInOutQuad(progress);&#10;                currentX = startX + (targetX - startX) * easeProgress;&#10;                currentY = startY + (targetY - startY) * easeProgress;&#10;            }&#10;        }&#10;&#10;        private double easeInOutQuad(double t) {&#10;            return t &lt; 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;&#10;        }&#10;&#10;        public void draw(Graphics2D g2d) {&#10;            // 繪製物品圓圈&#10;            g2d.setColor(color);&#10;            g2d.fillOval((int) currentX - ITEM_SIZE/2, (int) currentY - ITEM_SIZE/2, ITEM_SIZE, ITEM_SIZE);&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.setStroke(new BasicStroke(1));&#10;            g2d.drawOval((int) currentX - ITEM_SIZE/2, (int) currentY - ITEM_SIZE/2, ITEM_SIZE, ITEM_SIZE);&#10;&#10;            // 繪製物品編號&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;            String idText = String.valueOf(item.getId());&#10;            FontMetrics fm = g2d.getFontMetrics();&#10;            int textWidth = fm.stringWidth(idText);&#10;            int textHeight = fm.getHeight();&#10;            g2d.setColor(Color.WHITE);&#10;            g2d.drawString(idText, (int) currentX - textWidth/2, (int) currentY + textHeight/4);&#10;        }&#10;&#10;        public boolean isFinished() {&#10;            return progress &gt;= 1.0;&#10;        }&#10;    }&#10;&#10;    public void stopAnimation() {&#10;        if (animationTimer != null) {&#10;            animationTimer.stop();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.util.List;&#10;import java.util.concurrent.CopyOnWriteArrayList;&#10;&#10;public class FlowVisualizationPanel extends JPanel {&#10;    private final List&lt;AnimatedItem&gt; animatedItems = new CopyOnWriteArrayList&lt;&gt;();&#10;    private final Timer animationTimer;&#10;    &#10;    // 流程中的各個區域位置 - 動態計算以平均分配空間&#10;    private static final int CENTER_Y = 80;&#10;    private static final int ITEM_SIZE = 20;&#10;    private static final int MARGIN = 80; // 左右邊距&#10;    private static final int STATION_WIDTH = 60; // 每個站點的寬度&#10;    &#10;    public FlowVisualizationPanel() {&#10;        setPreferredSize(new Dimension(800, 160));&#10;        setBackground(new Color(240, 240, 240));&#10;        setBorder(BorderFactory.createTitledBorder(&quot; 物品流動動畫 (Item Flow Animation)&quot;));&#10;        &#10;        // 啟動動畫定時器&#10;        animationTimer = new Timer(50, e -&gt; {&#10;            updateAnimations();&#10;            repaint();&#10;        });&#10;        animationTimer.start();&#10;    }&#10;    &#10;    private void updateAnimations() {&#10;        // 移除已完成的動畫物品&#10;        animatedItems.removeIf(AnimatedItem::isFinished);&#10;        &#10;        // 更新所有動畫物品的位置&#10;        for (AnimatedItem item : animatedItems) {&#10;            item.update();&#10;        }&#10;    }&#10;    &#10;    // 動態計算各站點的 X 座標&#10;    private int getProducerX() {&#10;        return MARGIN + STATION_WIDTH / 2;&#10;    }&#10;    &#10;    private int getBufferX() {&#10;        int availableWidth = getWidth() - 2 * MARGIN;&#10;        return MARGIN + availableWidth / 3 + STATION_WIDTH / 2;&#10;    }&#10;    &#10;    private int getMachineX() {&#10;        int availableWidth = getWidth() - 2 * MARGIN;&#10;        return MARGIN + 2 * availableWidth / 3 + STATION_WIDTH / 2;&#10;    }&#10;    &#10;    private int getConsumerX() {&#10;        return getWidth() - MARGIN - STATION_WIDTH / 2;&#10;    }&#10;    &#10;    public void addProducerToBuffer(Item item) {&#10;        AnimatedItem animItem = new AnimatedItem(item, getProducerX(), CENTER_Y, getBufferX(), CENTER_Y, Color.GREEN);&#10;        animatedItems.add(animItem);&#10;    }&#10;    &#10;    public void addBufferToMachine(Item item) {&#10;        AnimatedItem animItem = new AnimatedItem(item, getBufferX(), CENTER_Y, getMachineX(), CENTER_Y, Color.BLUE);&#10;        animatedItems.add(animItem);&#10;    }&#10;    &#10;    public void addMachineToConsumer(Item item) {&#10;        AnimatedItem animItem = new AnimatedItem(item, getMachineX(), CENTER_Y, getConsumerX(), CENTER_Y, Color.RED);&#10;        animatedItems.add(animItem);&#10;    }&#10;    &#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        Graphics2D g2d = (Graphics2D) g;&#10;        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;        &#10;        // 繪製流程圖框架&#10;        drawFlowFramework(g2d);&#10;        &#10;        // 繪製動畫中的物品&#10;        for (AnimatedItem item : animatedItems) {&#10;            item.draw(g2d);&#10;        }&#10;    }&#10;    &#10;    private void drawFlowFramework(Graphics2D g2d) {&#10;        // 計算各站點位置&#10;        int producerX = getProducerX();&#10;        int bufferX = getBufferX();&#10;        int machineX = getMachineX();&#10;        int consumerX = getConsumerX();&#10;        &#10;        // 繪製各個區域的框架&#10;        drawStationBox(g2d, producerX - STATION_WIDTH/2, CENTER_Y - 25, &quot; 生產者&quot;, Color.GREEN);&#10;        drawStationBox(g2d, bufferX - STATION_WIDTH/2, CENTER_Y - 25, &quot; 緩衝區&quot;, Color.ORANGE);&#10;        drawStationBox(g2d, machineX - STATION_WIDTH/2, CENTER_Y - 25, &quot;⚙️ 機台&quot;, Color.BLUE);&#10;        drawStationBox(g2d, consumerX - STATION_WIDTH/2, CENTER_Y - 25, &quot; 消費者&quot;, Color.RED);&#10;        &#10;        // 繪製箭頭連接線&#10;        drawArrow(g2d, producerX + STATION_WIDTH/2, CENTER_Y, bufferX - STATION_WIDTH/2, CENTER_Y);&#10;        drawArrow(g2d, bufferX + STATION_WIDTH/2, CENTER_Y, machineX - STATION_WIDTH/2, CENTER_Y);&#10;        drawArrow(g2d, machineX + STATION_WIDTH/2, CENTER_Y, consumerX - STATION_WIDTH/2, CENTER_Y);&#10;        &#10;        // 添加說明文字&#10;        g2d.setColor(Color.BLACK);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 10));&#10;        &#10;        // 計算箭頭中點位置來放置說明文字&#10;        int arrow1MidX = (producerX + STATION_WIDTH/2 + bufferX - STATION_WIDTH/2) / 2;&#10;        int arrow2MidX = (bufferX + STATION_WIDTH/2 + machineX - STATION_WIDTH/2) / 2;&#10;        int arrow3MidX = (machineX + STATION_WIDTH/2 + consumerX - STATION_WIDTH/2) / 2;&#10;        &#10;        g2d.drawString(&quot;0.2s&quot;, arrow1MidX - 10, CENTER_Y - 10);&#10;        g2d.drawString(&quot;0.24s&quot;, arrow2MidX - 15, CENTER_Y - 10);&#10;        g2d.drawString(&quot;0.24s&quot;, arrow3MidX - 15, CENTER_Y - 10);&#10;    }&#10;    &#10;    private void drawStationBox(Graphics2D g2d, int x, int y, String label, Color color) {&#10;        g2d.setColor(color.brighter().brighter());&#10;        g2d.fillRoundRect(x, y, STATION_WIDTH, 50, 10, 10);&#10;        g2d.setColor(color);&#10;        g2d.setStroke(new BasicStroke(2));&#10;        g2d.drawRoundRect(x, y, STATION_WIDTH, 50, 10, 10);&#10;        &#10;        g2d.setColor(Color.BLACK);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 9));&#10;        FontMetrics fm = g2d.getFontMetrics();&#10;        int textWidth = fm.stringWidth(label);&#10;        g2d.drawString(label, x + (STATION_WIDTH - textWidth) / 2, y + 60);&#10;    }&#10;    &#10;    private void drawArrow(Graphics2D g2d, int x1, int y1, int x2, int y2) {&#10;        g2d.setColor(Color.GRAY);&#10;        g2d.setStroke(new BasicStroke(2));&#10;        g2d.drawLine(x1, y1, x2, y2);&#10;        &#10;        // 繪製箭頭頭部&#10;        int arrowLength = 8;&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#10;        &#10;        int arrowX1 = (int) (x2 - arrowLength * Math.cos(angle - Math.PI / 6));&#10;        int arrowY1 = (int) (y2 - arrowLength * Math.sin(angle - Math.PI / 6));&#10;        int arrowX2 = (int) (x2 - arrowLength * Math.cos(angle + Math.PI / 6));&#10;        int arrowY2 = (int) (y2 - arrowLength * Math.sin(angle + Math.PI / 6));&#10;        &#10;        g2d.drawLine(x2, y2, arrowX1, arrowY1);&#10;        g2d.drawLine(x2, y2, arrowX2, arrowY2);&#10;    }&#10;    &#10;    // 內部類：動畫物品&#10;    private static class AnimatedItem {&#10;        private final Item item;&#10;        private double currentX, currentY;&#10;        private final double targetX, targetY;&#10;        private final double startX, startY;&#10;        private final Color color;&#10;        private double progress = 0.0;&#10;        private static final double ANIMATION_SPEED = 0.02;&#10;        &#10;        public AnimatedItem(Item item, double startX, double startY, double targetX, double targetY, Color color) {&#10;            this.item = item;&#10;            this.startX = startX;&#10;            this.startY = startY;&#10;            this.currentX = startX;&#10;            this.currentY = startY;&#10;            this.targetX = targetX;&#10;            this.targetY = targetY;&#10;            this.color = color;&#10;        }&#10;        &#10;        public void update() {&#10;            if (progress &lt; 1.0) {&#10;                progress += ANIMATION_SPEED;&#10;                if (progress &gt; 1.0) progress = 1.0;&#10;                &#10;                // 使用緩動函數讓動畫更平滑&#10;                double easeProgress = easeInOutQuad(progress);&#10;                currentX = startX + (targetX - startX) * easeProgress;&#10;                currentY = startY + (targetY - startY) * easeProgress;&#10;            }&#10;        }&#10;        &#10;        private double easeInOutQuad(double t) {&#10;            return t &lt; 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;&#10;        }&#10;        &#10;        public void draw(Graphics2D g2d) {&#10;            // 繪製物品圓圈&#10;            g2d.setColor(color);&#10;            g2d.fillOval((int) currentX - ITEM_SIZE/2, (int) currentY - ITEM_SIZE/2, ITEM_SIZE, ITEM_SIZE);&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.setStroke(new BasicStroke(1));&#10;            g2d.drawOval((int) currentX - ITEM_SIZE/2, (int) currentY - ITEM_SIZE/2, ITEM_SIZE, ITEM_SIZE);&#10;            &#10;            // 繪製物品編號&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;            String idText = String.valueOf(item.getId());&#10;            FontMetrics fm = g2d.getFontMetrics();&#10;            int textWidth = fm.stringWidth(idText);&#10;            int textHeight = fm.getHeight();&#10;            g2d.setColor(Color.WHITE);&#10;            g2d.drawString(idText, (int) currentX - textWidth/2, (int) currentY + textHeight/4);&#10;        }&#10;        &#10;        public boolean isFinished() {&#10;            return progress &gt;= 1.0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/Machine.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/Machine.java" />
              <option name="originalContent" value="public class Machine extends Thread {&#10;    private final MinHeapBuffer buffer;&#10;    private final ProcessedQueue processedQueue;&#10;    private final int processIntervalMs;&#10;    private final ProducerConsumerGUI gui;&#10;    private volatile boolean running = true;&#10;&#10;    public Machine(MinHeapBuffer buffer, ProcessedQueue processedQueue, int processIntervalMs, ProducerConsumerGUI gui) {&#10;        this.buffer = buffer;&#10;        this.processedQueue = processedQueue;&#10;        this.processIntervalMs = processIntervalMs;&#10;        this.gui = gui;&#10;    }&#10;&#10;    public void stopMachine() {&#10;        running = false;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        try {&#10;            while (running) {&#10;                Item item = buffer.take();&#10;                String message = &quot;機台處理: &quot; + item;&#10;                System.out.println(message);&#10;                if (gui != null) {&#10;                    gui.appendToMachine(message);&#10;                }&#10;                // 處理後放入暫存區&#10;                processedQueue.put(item);&#10;                Thread.sleep(processIntervalMs);&#10;            }&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="public class Machine extends Thread {&#10;    private final MinHeapBuffer buffer;&#10;    private final ProcessedQueue processedQueue;&#10;    private final int processIntervalMs;&#10;    private final ProducerConsumerGUI gui;&#10;    private volatile boolean running = true;&#10;&#10;    public Machine(MinHeapBuffer buffer, ProcessedQueue processedQueue, int processIntervalMs, ProducerConsumerGUI gui) {&#10;        this.buffer = buffer;&#10;        this.processedQueue = processedQueue;&#10;        this.processIntervalMs = processIntervalMs;&#10;        this.gui = gui;&#10;    }&#10;&#10;    public void stopMachine() {&#10;        running = false;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        try {&#10;            while (running) {&#10;                Item item = buffer.take();&#10;                if (gui != null) {&#10;                    gui.triggerBufferToMachineAnimation(item); // 觸發緩衝區到機台的動畫&#10;                }&#10;                String message = &quot;機台處理: &quot; + item;&#10;                System.out.println(message);&#10;                if (gui != null) {&#10;                    gui.appendToMachine(message);&#10;                }&#10;                // 處理後放入暫存區&#10;                processedQueue.put(item);&#10;                if (gui != null) {&#10;                    gui.triggerMachineToConsumerAnimation(item); // 觸發機台到消費者的動畫&#10;                }&#10;                Thread.sleep(processIntervalMs);&#10;            }&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/Main.java" />
              <option name="updatedContent" value="public class Main {&#10;    public static void main(String[] args) {&#10;        ProducerConsumerGUI.main(args);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/MinHeapBuffer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/MinHeapBuffer.java" />
              <option name="originalContent" value="import java.util.PriorityQueue;&#10;import java.util.Queue;&#10;&#10;public class MinHeapBuffer {&#10;    private final int capacity;&#10;    private final Queue&lt;Item&gt; heap;&#10;&#10;    public MinHeapBuffer(int capacity) {&#10;        this.capacity = capacity;&#10;        this.heap = new PriorityQueue&lt;&gt;();&#10;    }&#10;&#10;    public synchronized void put(Item item) throws InterruptedException {&#10;        while (heap.size() &gt;= capacity) {&#10;            wait();&#10;        }&#10;        heap.offer(item);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized Item take() throws InterruptedException {&#10;        while (heap.isEmpty()) {&#10;            wait();&#10;        }&#10;        Item item = heap.poll();&#10;        notifyAll();&#10;        return item;&#10;    }&#10;&#10;    public synchronized int size() {&#10;        return heap.size();&#10;    }&#10;&#10;    public synchronized boolean isFull() {&#10;        return heap.size() &gt;= capacity;&#10;    }&#10;&#10;    public synchronized boolean isEmpty() {&#10;        return heap.isEmpty();&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import java.util.PriorityQueue;&#10;import java.util.Queue;&#10;&#10;public class MinHeapBuffer {&#10;    private final int capacity;&#10;    private final Queue&lt;Item&gt; heap;&#10;&#10;    public MinHeapBuffer(int capacity) {&#10;        this.capacity = capacity;&#10;        this.heap = new PriorityQueue&lt;&gt;();&#10;    }&#10;&#10;    public synchronized void put(Item item) throws InterruptedException {&#10;        while (heap.size() &gt;= capacity) {&#10;            wait();&#10;        }&#10;        heap.offer(item);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized Item take() throws InterruptedException {&#10;        while (heap.isEmpty()) {&#10;            wait();&#10;        }&#10;        Item item = heap.poll();&#10;        notifyAll();&#10;        return item;&#10;    }&#10;&#10;    public synchronized int size() {&#10;        return heap.size();&#10;    }&#10;&#10;    public synchronized boolean isFull() {&#10;        return heap.size() &gt;= capacity;&#10;    }&#10;&#10;    public synchronized boolean isEmpty() {&#10;        return heap.isEmpty();&#10;    }&#10;&#10;    public synchronized String itemsInfo() {&#10;        StringBuilder sb = new StringBuilder();&#10;        for (Item item : heap) {&#10;            sb.append(item.toString()).append(&quot;\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/ProcessedQueue.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/ProcessedQueue.java" />
              <option name="updatedContent" value="import java.util.LinkedList;&#10;import java.util.Queue;&#10;&#10;public class ProcessedQueue {&#10;    private final Queue&lt;Item&gt; queue = new LinkedList&lt;&gt;();&#10;    private final int capacity;&#10;&#10;    public ProcessedQueue(int capacity) {&#10;        this.capacity = capacity;&#10;    }&#10;&#10;    public synchronized void put(Item item) throws InterruptedException {&#10;        while (queue.size() &gt;= capacity) {&#10;            wait();&#10;        }&#10;        queue.offer(item);&#10;        notifyAll();&#10;    }&#10;&#10;    public synchronized Item take() throws InterruptedException {&#10;        while (queue.isEmpty()) {&#10;            wait();&#10;        }&#10;        Item item = queue.poll();&#10;        notifyAll();&#10;        return item;&#10;    }&#10;&#10;    public synchronized int size() {&#10;        return queue.size();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/Producer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/Producer.java" />
              <option name="originalContent" value="public class Producer extends Thread {&#10;    private final MinHeapBuffer buffer;&#10;    private final int produceIntervalMs;&#10;    private final ProducerConsumerGUI gui;&#10;    private int nextId = 1;&#10;    private volatile boolean running = true;&#10;&#10;    public Producer(MinHeapBuffer buffer, int produceIntervalMs) {&#10;        this(buffer, produceIntervalMs, null);&#10;    }&#10;&#10;    public Producer(MinHeapBuffer buffer, int produceIntervalMs, ProducerConsumerGUI gui) {&#10;        this.buffer = buffer;&#10;        this.produceIntervalMs = produceIntervalMs;&#10;        this.gui = gui;&#10;    }&#10;&#10;    public void stopProducer() {&#10;        running = false;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        try {&#10;            while (running) {&#10;                Item item = new Item(); // 使用隨機編號建構子&#10;                buffer.put(item);&#10;                String message = &quot;生產: &quot; + item;&#10;                System.out.println(message);&#10;                if (gui != null) {&#10;                    gui.appendToProducer(message);&#10;                }&#10;                Thread.sleep(produceIntervalMs);&#10;            }&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="public class Producer extends Thread {&#10;    private final MinHeapBuffer buffer;&#10;    private final int produceIntervalMs;&#10;    private final ProducerConsumerGUI gui;&#10;    private int nextId = 1;&#10;    private volatile boolean running = true;&#10;&#10;    public Producer(MinHeapBuffer buffer, int produceIntervalMs) {&#10;        this(buffer, produceIntervalMs, null);&#10;    }&#10;&#10;    public Producer(MinHeapBuffer buffer, int produceIntervalMs, ProducerConsumerGUI gui) {&#10;        this.buffer = buffer;&#10;        this.produceIntervalMs = produceIntervalMs;&#10;        this.gui = gui;&#10;    }&#10;&#10;    public void stopProducer() {&#10;        running = false;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        try {&#10;            while (running) {&#10;                Item item = new Item(); // 使用隨機編號建構子&#10;                buffer.put(item);&#10;                String message = &quot;生產: &quot; + item;&#10;                System.out.println(message);&#10;                if (gui != null) {&#10;                    gui.appendToProducer(message);&#10;                    gui.triggerProducerToBufferAnimation(item); // 觸發動畫&#10;                }&#10;                Thread.sleep(produceIntervalMs);&#10;            }&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/ProducerConsumerGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/ProducerConsumerGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;&#10;public class ProducerConsumerGUI extends JFrame {&#10;    private JTextField bufferSizeField;&#10;    private JButton startButton;&#10;    private JButton stopButton;&#10;    private JTextArea producerArea;&#10;    private JTextArea bufferStatusArea;&#10;    private JTextArea machineArea;&#10;    private JTextArea consumerArea;&#10;    private JLabel bufferSizeLabel;&#10;    private JLabel currentBufferSizeLabel;&#10;&#10;    private MinHeapBuffer buffer;&#10;    private Producer producer;&#10;    private EnhancedConsumer consumer;&#10;    private ProcessedQueue processedQueue;&#10;    private Machine machine;&#10;    private Timer updateTimer;&#10;&#10;    public ProducerConsumerGUI() {&#10;        initializeComponents();&#10;        setupLayout();&#10;        setupEventHandlers();&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setTitle(&quot;生產者-消費者模擬 (Min-Heap Buffer) - 四區域顯示&quot;);&#10;        setSize(1000, 700);&#10;        setLocationRelativeTo(null);&#10;    }&#10;&#10;    private void initializeComponents() {&#10;        // 控制面板元件&#10;        bufferSizeField = new JTextField(&quot;10&quot;, 10);&#10;        startButton = new JButton(&quot;開始生產&quot;);&#10;        stopButton = new JButton(&quot;停止生產&quot;);&#10;        stopButton.setEnabled(false);&#10;&#10;        // 四個顯示區域&#10;        producerArea = new JTextArea(15, 25);&#10;        producerArea.setEditable(false);&#10;        producerArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));&#10;        producerArea.setBackground(new Color(230, 255, 230)); // 淺綠色&#10;&#10;        bufferStatusArea = new JTextArea(15, 25);&#10;        bufferStatusArea.setEditable(false);&#10;        bufferStatusArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));&#10;        bufferStatusArea.setBackground(new Color(255, 255, 230)); // 淺黃色&#10;&#10;        machineArea = new JTextArea(15, 25);&#10;        machineArea.setEditable(false);&#10;        machineArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));&#10;        machineArea.setBackground(new Color(230, 230, 255)); // 淺藍色&#10;&#10;        consumerArea = new JTextArea(15, 25);&#10;        consumerArea.setEditable(false);&#10;        consumerArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));&#10;        consumerArea.setBackground(new Color(255, 230, 230)); // 淺紅色&#10;&#10;        bufferSizeLabel = new JLabel(&quot;緩衝區大小:&quot;);&#10;        currentBufferSizeLabel = new JLabel(&quot;當前緩衝區: 0/0&quot;);&#10;    }&#10;&#10;    private void setupLayout() {&#10;        setLayout(new BorderLayout());&#10;&#10;        // 控制面板&#10;        JPanel controlPanel = new JPanel(new FlowLayout());&#10;        controlPanel.add(bufferSizeLabel);&#10;        controlPanel.add(bufferSizeField);&#10;        controlPanel.add(startButton);&#10;        controlPanel.add(stopButton);&#10;        controlPanel.add(Box.createHorizontalStrut(20));&#10;        controlPanel.add(currentBufferSizeLabel);&#10;&#10;        // 四區域顯示面板&#10;        JPanel mainPanel = new JPanel(new GridLayout(2, 2, 10, 10));&#10;        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));&#10;&#10;        // 生產者區域&#10;        JPanel producerPanel = new JPanel(new BorderLayout());&#10;        producerPanel.setBorder(BorderFactory.createTitledBorder(&quot; 生產者 (Producer)&quot;));&#10;        producerPanel.add(new JScrollPane(producerArea), BorderLayout.CENTER);&#10;&#10;        // Buffer 狀態區域&#10;        JPanel bufferPanel = new JPanel(new BorderLayout());&#10;        bufferPanel.setBorder(BorderFactory.createTitledBorder(&quot; 緩衝區狀態 (Buffer Status)&quot;));&#10;        bufferPanel.add(new JScrollPane(bufferStatusArea), BorderLayout.CENTER);&#10;&#10;        // 機台區域&#10;        JPanel machinePanel = new JPanel(new BorderLayout());&#10;        machinePanel.setBorder(BorderFactory.createTitledBorder(&quot;⚙️ 機台處理 (Machine Processing)&quot;));&#10;        machinePanel.add(new JScrollPane(machineArea), BorderLayout.CENTER);&#10;&#10;        // 消費者區域&#10;        JPanel consumerPanel = new JPanel(new BorderLayout());&#10;        consumerPanel.setBorder(BorderFactory.createTitledBorder(&quot; 消費者 (Consumer)&quot;));&#10;        consumerPanel.add(new JScrollPane(consumerArea), BorderLayout.CENTER);&#10;&#10;        // 按順序添加到主面板&#10;        mainPanel.add(producerPanel);&#10;        mainPanel.add(bufferPanel);&#10;        mainPanel.add(machinePanel);&#10;        mainPanel.add(consumerPanel);&#10;&#10;        add(controlPanel, BorderLayout.NORTH);&#10;        add(mainPanel, BorderLayout.CENTER);&#10;    }&#10;&#10;    private void setupEventHandlers() {&#10;        startButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                startProduction();&#10;            }&#10;        });&#10;&#10;        stopButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                stopProduction();&#10;            }&#10;        });&#10;    }&#10;&#10;    private void startProduction() {&#10;        try {&#10;            int bufferSize = Integer.parseInt(bufferSizeField.getText());&#10;            if (bufferSize &lt;= 0) {&#10;                JOptionPane.showMessageDialog(this, &quot;緩衝區大小必須大於 0&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                return;&#10;            }&#10;&#10;            // 清空所有顯示區域&#10;            clearAllAreas();&#10;&#10;            // 初始化緩衝區和執行緒&#10;            buffer = new MinHeapBuffer(bufferSize);&#10;            processedQueue = new ProcessedQueue(bufferSize); // 暫存區容量同 buffer&#10;            producer = new Producer(buffer, 200, this);&#10;            machine = new Machine(buffer, processedQueue, 240, this);&#10;            consumer = new EnhancedConsumer(processedQueue, 240, this);&#10;&#10;            // 啟動執行緒&#10;            producer.start();&#10;            machine.start();&#10;            consumer.start();&#10;&#10;            // 更新 UI 狀態&#10;            startButton.setEnabled(false);&#10;            stopButton.setEnabled(true);&#10;            bufferSizeField.setEnabled(false);&#10;&#10;            // 啟動定時更新&#10;            startUpdateTimer();&#10;&#10;            appendToMachine(&quot;=== 系統啟動 ===&quot;);&#10;            appendToMachine(&quot;緩衝區大小: &quot; + bufferSize);&#10;            appendToMachine(&quot;生產週期: 200ms&quot;);&#10;            appendToMachine(&quot;機台處理週期: 240ms&quot;);&#10;            appendToMachine(&quot;消費週期: 240ms&quot;);&#10;&#10;        } catch (NumberFormatException ex) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入有效的數字&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;        }&#10;    }&#10;&#10;    private void stopProduction() {&#10;        if (producer != null) {&#10;            producer.stopProducer();&#10;        }&#10;        if (machine != null) {&#10;            machine.stopMachine();&#10;        }&#10;        if (consumer != null) {&#10;            consumer.stopConsumer();&#10;        }&#10;        if (updateTimer != null) {&#10;            updateTimer.stop();&#10;        }&#10;&#10;        // 重設 UI 狀態&#10;        startButton.setEnabled(true);&#10;        stopButton.setEnabled(false);&#10;        bufferSizeField.setEnabled(true);&#10;&#10;        appendToMachine(&quot;=== 系統停止 ===&quot;);&#10;    }&#10;&#10;    private void clearAllAreas() {&#10;        producerArea.setText(&quot;&quot;);&#10;        bufferStatusArea.setText(&quot;&quot;);&#10;        machineArea.setText(&quot;&quot;);&#10;        consumerArea.setText(&quot;&quot;);&#10;    }&#10;&#10;    private void startUpdateTimer() {&#10;        updateTimer = new Timer(100, new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                updateBufferStatus();&#10;            }&#10;        });&#10;        updateTimer.start();&#10;    }&#10;&#10;    private void updateBufferStatus() {&#10;        if (buffer != null) {&#10;            int currentSize = buffer.size();&#10;            int capacity = Integer.parseInt(bufferSizeField.getText());&#10;            currentBufferSizeLabel.setText(&quot;當前緩衝區: &quot; + currentSize + &quot;/&quot; + capacity);&#10;&#10;            // 更新緩衝區狀態顯示&#10;            StringBuilder status = new StringBuilder();&#10;            status.append(&quot;=== 緩衝區即時狀態 ===\n&quot;);&#10;            status.append(&quot;容量: &quot;).append(capacity).append(&quot;\n&quot;);&#10;            status.append(&quot;當前大小: &quot;).append(currentSize).append(&quot;\n&quot;);&#10;            status.append(&quot;使用率: &quot;).append(String.format(&quot;%.1f%%&quot;, (double) currentSize / capacity * 100)).append(&quot;\n&quot;);&#10;            status.append(&quot;狀態: &quot;);&#10;            if (buffer.isFull()) {&#10;                status.append(&quot; 已滿\n&quot;);&#10;            } else if (buffer.isEmpty()) {&#10;                status.append(&quot;⚪ 空的\n&quot;);&#10;            } else {&#10;                status.append(&quot; 正常\n&quot;);&#10;            }&#10;&#10;            // 顯示進度條&#10;            int barLength = 20;&#10;            int filled = (int) ((double) currentSize / capacity * barLength);&#10;            status.append(&quot;進度: [&quot;);&#10;            for (int i = 0; i &lt; barLength; i++) {&#10;                if (i &lt; filled) {&#10;                    status.append(&quot;█&quot;);&#10;                } else {&#10;                    status.append(&quot;░&quot;);&#10;                }&#10;            }&#10;            status.append(&quot;]\n\n&quot;);&#10;&#10;            status.append(&quot;=== Buffer 內容 ===\n&quot;);&#10;            status.append(buffer.itemsInfo());&#10;            status.append(&quot;\n&quot;);&#10;&#10;            status.append(&quot;=== 歷史統計 ===\n&quot;);&#10;            // 這裡可以添加更多統計信息&#10;&#10;            bufferStatusArea.setText(status.toString());&#10;        }&#10;    }&#10;&#10;    // 四個區域的訊息添加方法&#10;    public void appendToProducer(String message) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            producerArea.append(getCurrentTime() + &quot; &quot; + message + &quot;\n&quot;);&#10;            producerArea.setCaretPosition(producerArea.getDocument().getLength());&#10;        });&#10;    }&#10;&#10;    public void appendToMachine(String message) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            machineArea.append(getCurrentTime() + &quot; &quot; + message + &quot;\n&quot;);&#10;            machineArea.setCaretPosition(machineArea.getDocument().getLength());&#10;        });&#10;    }&#10;&#10;    public void appendToConsumer(String message) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            consumerArea.append(getCurrentTime() + &quot; &quot; + message + &quot;\n&quot;);&#10;            consumerArea.setCaretPosition(consumerArea.getDocument().getLength());&#10;        });&#10;    }&#10;&#10;    private String getCurrentTime() {&#10;        return String.format(&quot;[%02d:%02d:%02d]&quot;,&#10;                (System.currentTimeMillis() / 1000) % 86400 / 3600,&#10;                (System.currentTimeMillis() / 1000) % 3600 / 60,&#10;                (System.currentTimeMillis() / 1000) % 60);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            try {&#10;                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;            new ProducerConsumerGUI().setVisible(true);&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;&#10;public class ProducerConsumerGUI extends JFrame {&#10;    private JTextField bufferSizeField;&#10;    private JButton startButton;&#10;    private JButton stopButton;&#10;    private JTextArea producerArea;&#10;    private JTextArea bufferStatusArea;&#10;    private JTextArea machineArea;&#10;    private JTextArea consumerArea;&#10;    private JLabel bufferSizeLabel;&#10;    private JLabel currentBufferSizeLabel;&#10;&#10;    private MinHeapBuffer buffer;&#10;    private Producer producer;&#10;    private EnhancedConsumer consumer;&#10;    private ProcessedQueue processedQueue;&#10;    private Machine machine;&#10;    private Timer updateTimer;&#10;    private FlowVisualizationPanel flowPanel;&#10;&#10;    public ProducerConsumerGUI() {&#10;        initializeComponents();&#10;        setupLayout();&#10;        setupEventHandlers();&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setTitle(&quot;生產者-消費者模擬 (Min-Heap Buffer) - 四區域顯示&quot;);&#10;        setSize(1000, 700);&#10;        setLocationRelativeTo(null);&#10;    }&#10;&#10;    private void initializeComponents() {&#10;        // 控制面板元件&#10;        bufferSizeField = new JTextField(&quot;10&quot;, 10);&#10;        startButton = new JButton(&quot;開始生產&quot;);&#10;        stopButton = new JButton(&quot;停止生產&quot;);&#10;        stopButton.setEnabled(false);&#10;&#10;        // 四個顯示區域&#10;        producerArea = new JTextArea(15, 25);&#10;        producerArea.setEditable(false);&#10;        producerArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));&#10;        producerArea.setBackground(new Color(230, 255, 230)); // 淺綠色&#10;&#10;        bufferStatusArea = new JTextArea(15, 25);&#10;        bufferStatusArea.setEditable(false);&#10;        bufferStatusArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));&#10;        bufferStatusArea.setBackground(new Color(255, 255, 230)); // 淺黃色&#10;&#10;        machineArea = new JTextArea(15, 25);&#10;        machineArea.setEditable(false);&#10;        machineArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));&#10;        machineArea.setBackground(new Color(230, 230, 255)); // 淺藍色&#10;&#10;        consumerArea = new JTextArea(15, 25);&#10;        consumerArea.setEditable(false);&#10;        consumerArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 11));&#10;        consumerArea.setBackground(new Color(255, 230, 230)); // 淺紅色&#10;&#10;        bufferSizeLabel = new JLabel(&quot;緩衝區大小:&quot;);&#10;        currentBufferSizeLabel = new JLabel(&quot;當前緩衝區: 0/0&quot;);&#10;        &#10;        // 初始化流程動畫面板&#10;        flowPanel = new FlowVisualizationPanel();&#10;    }&#10;&#10;    private void setupLayout() {&#10;        setLayout(new BorderLayout());&#10;&#10;        // 控制面板&#10;        JPanel controlPanel = new JPanel(new FlowLayout());&#10;        controlPanel.add(bufferSizeLabel);&#10;        controlPanel.add(bufferSizeField);&#10;        controlPanel.add(startButton);&#10;        controlPanel.add(stopButton);&#10;        controlPanel.add(Box.createHorizontalStrut(20));&#10;        controlPanel.add(currentBufferSizeLabel);&#10;&#10;        // 四區域顯示面板&#10;        JPanel mainPanel = new JPanel(new GridLayout(2, 2, 10, 10));&#10;        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));&#10;&#10;        // 生產者區域&#10;        JPanel producerPanel = new JPanel(new BorderLayout());&#10;        producerPanel.setBorder(BorderFactory.createTitledBorder(&quot; 生產者 (Producer)&quot;));&#10;        producerPanel.add(new JScrollPane(producerArea), BorderLayout.CENTER);&#10;&#10;        // Buffer 狀態區域&#10;        JPanel bufferPanel = new JPanel(new BorderLayout());&#10;        bufferPanel.setBorder(BorderFactory.createTitledBorder(&quot; 緩衝區狀態 (Buffer Status)&quot;));&#10;        bufferPanel.add(new JScrollPane(bufferStatusArea), BorderLayout.CENTER);&#10;&#10;        // 機台區域&#10;        JPanel machinePanel = new JPanel(new BorderLayout());&#10;        machinePanel.setBorder(BorderFactory.createTitledBorder(&quot;⚙️ 機台處理 (Machine Processing)&quot;));&#10;        machinePanel.add(new JScrollPane(machineArea), BorderLayout.CENTER);&#10;&#10;        // 消費者區域&#10;        JPanel consumerPanel = new JPanel(new BorderLayout());&#10;        consumerPanel.setBorder(BorderFactory.createTitledBorder(&quot; 消費者 (Consumer)&quot;));&#10;        consumerPanel.add(new JScrollPane(consumerArea), BorderLayout.CENTER);&#10;&#10;        // 按順序添加到主面板&#10;        mainPanel.add(producerPanel);&#10;        mainPanel.add(bufferPanel);&#10;        mainPanel.add(machinePanel);&#10;        mainPanel.add(consumerPanel);&#10;&#10;        add(controlPanel, BorderLayout.NORTH);&#10;        add(mainPanel, BorderLayout.CENTER);&#10;        add(flowPanel, BorderLayout.SOUTH);&#10;    }&#10;&#10;    private void setupEventHandlers() {&#10;        startButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                startProduction();&#10;            }&#10;        });&#10;&#10;        stopButton.addActionListener(new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                stopProduction();&#10;            }&#10;        });&#10;    }&#10;&#10;    private void startProduction() {&#10;        try {&#10;            int bufferSize = Integer.parseInt(bufferSizeField.getText());&#10;            if (bufferSize &lt;= 0) {&#10;                JOptionPane.showMessageDialog(this, &quot;緩衝區大小必須大於 0&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;                return;&#10;            }&#10;&#10;            // 清空所有顯示區域&#10;            clearAllAreas();&#10;&#10;            // 初始化緩衝區和執行緒&#10;            buffer = new MinHeapBuffer(bufferSize);&#10;            processedQueue = new ProcessedQueue(bufferSize); // 暫存區容量同 buffer&#10;            producer = new Producer(buffer, 200, this);&#10;            machine = new Machine(buffer, processedQueue, 240, this);&#10;            consumer = new EnhancedConsumer(processedQueue, 240, this);&#10;&#10;            // 啟動執行緒&#10;            producer.start();&#10;            machine.start();&#10;            consumer.start();&#10;&#10;            // 更新 UI 狀態&#10;            startButton.setEnabled(false);&#10;            stopButton.setEnabled(true);&#10;            bufferSizeField.setEnabled(false);&#10;&#10;            // 啟動定時更新&#10;            startUpdateTimer();&#10;&#10;            appendToMachine(&quot;=== 系統啟動 ===&quot;);&#10;            appendToMachine(&quot;緩衝區大小: &quot; + bufferSize);&#10;            appendToMachine(&quot;生產週期: 200ms&quot;);&#10;            appendToMachine(&quot;機台處理週期: 240ms&quot;);&#10;            appendToMachine(&quot;消費週期: 240ms&quot;);&#10;&#10;        } catch (NumberFormatException ex) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入有效的數字&quot;, &quot;錯誤&quot;, JOptionPane.ERROR_MESSAGE);&#10;        }&#10;    }&#10;&#10;    private void stopProduction() {&#10;        if (producer != null) {&#10;            producer.stopProducer();&#10;        }&#10;        if (machine != null) {&#10;            machine.stopMachine();&#10;        }&#10;        if (consumer != null) {&#10;            consumer.stopConsumer();&#10;        }&#10;        if (updateTimer != null) {&#10;            updateTimer.stop();&#10;        }&#10;&#10;        // 重設 UI 狀態&#10;        startButton.setEnabled(true);&#10;        stopButton.setEnabled(false);&#10;        bufferSizeField.setEnabled(true);&#10;&#10;        appendToMachine(&quot;=== 系統停止 ===&quot;);&#10;    }&#10;&#10;    private void clearAllAreas() {&#10;        producerArea.setText(&quot;&quot;);&#10;        bufferStatusArea.setText(&quot;&quot;);&#10;        machineArea.setText(&quot;&quot;);&#10;        consumerArea.setText(&quot;&quot;);&#10;    }&#10;&#10;    private void startUpdateTimer() {&#10;        updateTimer = new Timer(100, new ActionListener() {&#10;            @Override&#10;            public void actionPerformed(ActionEvent e) {&#10;                updateBufferStatus();&#10;            }&#10;        });&#10;        updateTimer.start();&#10;    }&#10;&#10;    private void updateBufferStatus() {&#10;        if (buffer != null) {&#10;            int currentSize = buffer.size();&#10;            int capacity = Integer.parseInt(bufferSizeField.getText());&#10;            currentBufferSizeLabel.setText(&quot;當前緩衝區: &quot; + currentSize + &quot;/&quot; + capacity);&#10;&#10;            // 更新緩衝區狀態顯示&#10;            StringBuilder status = new StringBuilder();&#10;            status.append(&quot;=== 緩衝區即時狀態 ===\n&quot;);&#10;            status.append(&quot;容量: &quot;).append(capacity).append(&quot;\n&quot;);&#10;            status.append(&quot;當前大小: &quot;).append(currentSize).append(&quot;\n&quot;);&#10;            status.append(&quot;使用率: &quot;).append(String.format(&quot;%.1f%%&quot;, (double) currentSize / capacity * 100)).append(&quot;\n&quot;);&#10;            status.append(&quot;狀態: &quot;);&#10;            if (buffer.isFull()) {&#10;                status.append(&quot; 已滿\n&quot;);&#10;            } else if (buffer.isEmpty()) {&#10;                status.append(&quot;⚪ 空的\n&quot;);&#10;            } else {&#10;                status.append(&quot; 正常\n&quot;);&#10;            }&#10;&#10;            // 顯示進度條&#10;            int barLength = 20;&#10;            int filled = (int) ((double) currentSize / capacity * barLength);&#10;            status.append(&quot;進度: [&quot;);&#10;            for (int i = 0; i &lt; barLength; i++) {&#10;                if (i &lt; filled) {&#10;                    status.append(&quot;█&quot;);&#10;                } else {&#10;                    status.append(&quot;░&quot;);&#10;                }&#10;            }&#10;            status.append(&quot;]\n\n&quot;);&#10;&#10;            status.append(&quot;=== Buffer 內容 ===\n&quot;);&#10;            status.append(buffer.itemsInfo());&#10;            status.append(&quot;\n&quot;);&#10;&#10;            status.append(&quot;=== 歷史統計 ===\n&quot;);&#10;            // 這裡可以添加更多統計信息&#10;&#10;            bufferStatusArea.setText(status.toString());&#10;        }&#10;    }&#10;&#10;    // 四個區域的訊息添加方法&#10;    public void appendToProducer(String message) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            producerArea.append(getCurrentTime() + &quot; &quot; + message + &quot;\n&quot;);&#10;            producerArea.setCaretPosition(producerArea.getDocument().getLength());&#10;        });&#10;    }&#10;&#10;    public void appendToMachine(String message) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            machineArea.append(getCurrentTime() + &quot; &quot; + message + &quot;\n&quot;);&#10;            machineArea.setCaretPosition(machineArea.getDocument().getLength());&#10;        });&#10;    }&#10;&#10;    public void appendToConsumer(String message) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            consumerArea.append(getCurrentTime() + &quot; &quot; + message + &quot;\n&quot;);&#10;            consumerArea.setCaretPosition(consumerArea.getDocument().getLength());&#10;        });&#10;    }&#10;    &#10;    // 動畫觸發方法&#10;    public void triggerProducerToBufferAnimation(Item item) {&#10;        if (flowPanel != null) {&#10;            flowPanel.addProducerToBuffer(item);&#10;        }&#10;    }&#10;    &#10;    public void triggerBufferToMachineAnimation(Item item) {&#10;        if (flowPanel != null) {&#10;            flowPanel.addBufferToMachine(item);&#10;        }&#10;    }&#10;    &#10;    public void triggerMachineToConsumerAnimation(Item item) {&#10;        if (flowPanel != null) {&#10;            flowPanel.addMachineToConsumer(item);&#10;        }&#10;    }&#10;&#10;    private String getCurrentTime() {&#10;        return String.format(&quot;[%02d:%02d:%02d]&quot;,&#10;                (System.currentTimeMillis() / 1000) % 86400 / 3600,&#10;                (System.currentTimeMillis() / 1000) % 3600 / 60,&#10;                (System.currentTimeMillis() / 1000) % 60);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            try {&#10;                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());&#10;            } catch (Exception e) {&#10;                e.printStackTrace();&#10;            }&#10;            new ProducerConsumerGUI().setVisible(true);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/src/BinaryTreeArray.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/src/BinaryTreeArray.java" />
              <option name="originalContent" value="import java.util.*;&#10;import java.util.stream.IntStream;&#10;&#10;public class BinaryTreeArray {&#10;    private Integer[] treeArray;&#10;&#10;    public BinaryTreeArray(Integer[] arr) {&#10;        this.treeArray = arr;&#10;    }&#10;&#10;    // 工具方法：取得有效索引範圍（1 ~ arr.length-1）&#10;    private int getLeft(int index) { return 2 * index; }&#10;    private int getRight(int index) { return 2 * index + 1; }&#10;    private boolean isValidIndex(int index) { return index &gt; 0 &amp;&amp; index &lt; treeArray.length; }&#10;&#10;    // 前序走訪&#10;    public List&lt;Integer&gt; preorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        preorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void preorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        result.add(treeArray[index]);&#10;        preorderHelper(getLeft(index), result);&#10;        preorderHelper(getRight(index), result);&#10;    }&#10;&#10;    // 中序走訪&#10;    public List&lt;Integer&gt; inorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        inorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void inorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        inorderHelper(getLeft(index), result);&#10;        result.add(treeArray[index]);&#10;        inorderHelper(getRight(index), result);&#10;    }&#10;&#10;    // 後序走訪&#10;    public List&lt;Integer&gt; postorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        postorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void postorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        postorderHelper(getLeft(index), result);&#10;        postorderHelper(getRight(index), result);&#10;        result.add(treeArray[index]);&#10;    }&#10;&#10;    // 靜態方法：將字串陣列轉為 Integer 陣列（支援 null）&#10;    public static Integer[] parseInput(String input) {&#10;        String[] parts = input.split(&quot;,&quot;);&#10;        Integer[] arr = new Integer[parts.length + 1]; // arr[0] 保留&#10;        arr[0] = 0; // 節點數量初始化為0&#10;        for (int i = 0; i &lt; parts.length; i++) {&#10;            String s = parts[i].trim();&#10;            if (s.equalsIgnoreCase(&quot;null&quot;)) arr[i + 1] = null;&#10;            else arr[i + 1] = Integer.parseInt(s);&#10;            if (!s.equalsIgnoreCase(&quot;null&quot;)) arr[0]++;&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // 刪除指定索引的節點&#10;    // 若為樹葉節點則直接刪除，若為中間節點則刪除整個子樹&#10;    public void delete(int index) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        int left = getLeft(index);&#10;        int right = getRight(index);&#10;        boolean isLeaf = (!isValidIndex(left) || treeArray[left] == null)&#10;                &amp;&amp; (!isValidIndex(right) || treeArray[right] == null);&#10;        if (isLeaf) {&#10;            treeArray[index] = null;&#10;        } else {&#10;            deleteSubtree(index);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除以 index 為根的子樹&#10;    private void deleteSubtree(int index) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        treeArray[index] = null;&#10;        deleteSubtree(getLeft(index));&#10;        deleteSubtree(getRight(index));&#10;    }&#10;&#10;    // 測試主程式&#10;    public static void main(String[] args) {&#10;        Scanner sc = new Scanner(System.in);&#10;        System.out.println(&quot;請輸入以逗號分隔的陣列（用null表示空節點）：&quot;);&#10;        String input = sc.nextLine();&#10;        Integer[] arr = parseInput(input);&#10;        BinaryTreeArray tree = new BinaryTreeArray(arr);&#10;        System.out.println(&quot;索引:   &quot; + Arrays.toString(IntStream.range(1, arr.length).toArray()));&#10;        System.out.println(&quot;內容:   &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        System.out.println(&quot;節點數: &quot; + arr[0]);&#10;        System.out.println(&quot;中序: &quot; + tree.inorder());&#10;        System.out.println(&quot;前序: &quot; + tree.preorder());&#10;        System.out.println(&quot;後序: &quot; + tree.postorder());&#10;&#10;        while (true) {&#10;            System.out.println(&quot;請選擇操作: 1) 增加節點 2) 刪除節點 3) 退出&quot;);&#10;            String op = sc.nextLine();&#10;            if (op.equals(&quot;1&quot;)) {&#10;                System.out.print(&quot;請輸入要插入的索引: &quot;);&#10;                int idx = Integer.parseInt(sc.nextLine());&#10;                System.out.print(&quot;請輸入要插入的值(整數): &quot;);&#10;                String valStr = sc.nextLine();&#10;                Integer val = valStr.equalsIgnoreCase(&quot;null&quot;) ? null : Integer.parseInt(valStr);&#10;                if (idx &gt; 0 &amp;&amp; idx &lt; arr.length) {&#10;                    // 若原本為null且新值非null，節點數+1&#10;                    if (arr[idx] == null &amp;&amp; val != null) arr[0]++;&#10;                    // 若原本非null且新值為null，節點數-1&#10;                    if (arr[idx] != null &amp;&amp; val == null) arr[0]--;&#10;                    arr[idx] = val;&#10;                    System.out.println(&quot;已插入於索引 &quot; + idx);&#10;                } else {&#10;                    System.out.println(&quot;索引超出範圍&quot;);&#10;                }&#10;            } else if (op.equals(&quot;2&quot;)) {&#10;                System.out.print(&quot;請輸入要刪除的索引: &quot;);&#10;                int idx = Integer.parseInt(sc.nextLine());&#10;                // 遞迴計算刪除節點數&#10;                int[] delCount = new int[]{0};&#10;                countDelete(arr, idx, delCount);&#10;                tree.delete(idx);&#10;                arr[0] -= delCount[0];&#10;                System.out.println(&quot;已刪除索引 &quot; + idx);&#10;            } else if (op.equals(&quot;3&quot;)) {&#10;                System.out.println(&quot;程式結束&quot;);&#10;                break;&#10;            } else {&#10;                System.out.println(&quot;無效選項&quot;);&#10;            }&#10;            System.out.println(&quot;索引:   &quot; + Arrays.toString(IntStream.range(1, arr.length).toArray()));&#10;            System.out.println(&quot;內容:   &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;            System.out.println(&quot;節點數: &quot; + arr[0]);&#10;            System.out.println(&quot;中序: &quot; + tree.inorder());&#10;            System.out.println(&quot;前序: &quot; + tree.preorder());&#10;            System.out.println(&quot;後序: &quot; + tree.postorder());&#10;        }&#10;    }&#10;&#10;    // 遞迴計算將被刪除的節點數&#10;    private static void countDelete(Integer[] arr, int idx, int[] count) {&#10;        if (idx &lt;= 0 || idx &gt;= arr.length || arr[idx] == null) return;&#10;        count[0]++;&#10;        countDelete(arr, 2 * idx, count);&#10;        countDelete(arr, 2 * idx + 1, count);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.util.*;&#10;import java.util.stream.IntStream;&#10;&#10;public class BinaryTreeArray {&#10;    private Integer[] treeArray;&#10;&#10;    public BinaryTreeArray(Integer[] arr) {&#10;        this.treeArray = arr;&#10;    }&#10;&#10;    // 工具方法：取得有效索引範圍（1 ~ arr.length-1）&#10;    private int getLeft(int index) { return 2 * index; }&#10;    private int getRight(int index) { return 2 * index + 1; }&#10;    private boolean isValidIndex(int index) { return index &gt; 0 &amp;&amp; index &lt; treeArray.length; }&#10;&#10;    // 前序走訪&#10;    public List&lt;Integer&gt; preorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        preorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void preorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        result.add(treeArray[index]);&#10;        preorderHelper(getLeft(index), result);&#10;        preorderHelper(getRight(index), result);&#10;    }&#10;&#10;    // 中序走訪&#10;    public List&lt;Integer&gt; inorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        inorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void inorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        inorderHelper(getLeft(index), result);&#10;        result.add(treeArray[index]);&#10;        inorderHelper(getRight(index), result);&#10;    }&#10;&#10;    // 後序走訪&#10;    public List&lt;Integer&gt; postorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        postorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void postorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        postorderHelper(getLeft(index), result);&#10;        postorderHelper(getRight(index), result);&#10;        result.add(treeArray[index]);&#10;    }&#10;&#10;    // 靜態方法：將字串陣列轉為 Integer 陣列（支援 null）&#10;    public static Integer[] parseInput(String input) {&#10;        String[] parts = input.split(&quot;,&quot;);&#10;        Integer[] arr = new Integer[parts.length + 1]; // arr[0] 保留&#10;        arr[0] = 0; // 節點數量初始化為0&#10;        for (int i = 0; i &lt; parts.length; i++) {&#10;            String s = parts[i].trim();&#10;            if (s.equalsIgnoreCase(&quot;null&quot;)) arr[i + 1] = null;&#10;            else arr[i + 1] = Integer.parseInt(s);&#10;            if (!s.equalsIgnoreCase(&quot;null&quot;)) arr[0]++;&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // 刪除指定索引的節點&#10;    // 若為樹葉節點則直接刪除，若為中間節點則刪除整個子樹&#10;    public void delete(int index) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        int left = getLeft(index);&#10;        int right = getRight(index);&#10;        boolean isLeaf = (!isValidIndex(left) || treeArray[left] == null)&#10;                &amp;&amp; (!isValidIndex(right) || treeArray[right] == null);&#10;        if (isLeaf) {&#10;            treeArray[index] = null;&#10;        } else {&#10;            deleteSubtree(index);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除以 index 為根的子樹&#10;    private void deleteSubtree(int index) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        treeArray[index] = null;&#10;        deleteSubtree(getLeft(index));&#10;        deleteSubtree(getRight(index));&#10;    }&#10;&#10;    // 測試主程式&#10;    public static void main(String[] args) {&#10;        Scanner sc = new Scanner(System.in);&#10;        System.out.println(&quot;請輸入以逗號分隔的陣列（用null表示空節點）：&quot;);&#10;        System.out.println(&quot;或輸入 auto:N 由程式自動產生 N 個不重覆隨機數字&quot;);&#10;        String input = sc.nextLine();&#10;        Integer[] arr;&#10;        if (input.trim().toLowerCase().startsWith(&quot;auto:&quot;)) {&#10;            int n = 0;&#10;            try {&#10;                n = Integer.parseInt(input.trim().substring(5));&#10;            } catch (Exception e) {&#10;                System.out.println(&quot;格式錯誤，請輸入 auto:N，例如 auto:10&quot;);&#10;                return;&#10;            }&#10;            if (n &lt;= 0) {&#10;                System.out.println(&quot;N 必須大於 0&quot;);&#10;                return;&#10;            }&#10;            Set&lt;Integer&gt; nums = new LinkedHashSet&lt;&gt;();&#10;            Random rand = new Random();&#10;            while (nums.size() &lt; n) {&#10;                nums.add(rand.nextInt(10000)); // 可調整範圍&#10;            }&#10;            arr = new Integer[n + 1];&#10;            arr[0] = n;&#10;            int i = 1;&#10;            for (int num : nums) arr[i++] = num;&#10;        } else {&#10;            arr = parseInput(input);&#10;        }&#10;        BinaryTreeArray tree = new BinaryTreeArray(arr);&#10;        System.out.println(&quot;索引:   &quot; + Arrays.toString(IntStream.range(1, arr.length).toArray()));&#10;        System.out.println(&quot;內容:   &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        System.out.println(&quot;節點數: &quot; + arr[0]);&#10;        System.out.println(&quot;中序: &quot; + tree.inorder());&#10;        System.out.println(&quot;前序: &quot; + tree.preorder());&#10;        System.out.println(&quot;後序: &quot; + tree.postorder());&#10;&#10;        while (true) {&#10;            System.out.println(&quot;請選擇操作: 1) 增加節點 2) 刪除節點 3) 退出&quot;);&#10;            String op = sc.nextLine();&#10;            if (op.equals(&quot;1&quot;)) {&#10;                System.out.print(&quot;請輸入要插入的索引: &quot;);&#10;                int idx = Integer.parseInt(sc.nextLine());&#10;                System.out.print(&quot;請輸入要插入的值(整數): &quot;);&#10;                String valStr = sc.nextLine();&#10;                Integer val = valStr.equalsIgnoreCase(&quot;null&quot;) ? null : Integer.parseInt(valStr);&#10;                if (idx &gt; 0 &amp;&amp; idx &lt; arr.length) {&#10;                    // 若原本為null且新值非null，節點數+1&#10;                    if (arr[idx] == null &amp;&amp; val != null) arr[0]++;&#10;                    // 若原本非null且新值為null，節點數-1&#10;                    if (arr[idx] != null &amp;&amp; val == null) arr[0]--;&#10;                    arr[idx] = val;&#10;                    System.out.println(&quot;已插入於索引 &quot; + idx);&#10;                } else {&#10;                    System.out.println(&quot;索引超出範圍&quot;);&#10;                }&#10;            } else if (op.equals(&quot;2&quot;)) {&#10;                System.out.print(&quot;請輸入要刪除的索引: &quot;);&#10;                int idx = Integer.parseInt(sc.nextLine());&#10;                // 遞迴計算刪除節點數&#10;                int[] delCount = new int[]{0};&#10;                countDelete(arr, idx, delCount);&#10;                tree.delete(idx);&#10;                arr[0] -= delCount[0];&#10;                System.out.println(&quot;已刪除索引 &quot; + idx);&#10;            } else if (op.equals(&quot;3&quot;)) {&#10;                System.out.println(&quot;程式結束&quot;);&#10;                break;&#10;            } else {&#10;                System.out.println(&quot;無效選項&quot;);&#10;            }&#10;            System.out.println(&quot;索引:   &quot; + Arrays.toString(IntStream.range(1, arr.length).toArray()));&#10;            System.out.println(&quot;內容:   &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;            System.out.println(&quot;節點數: &quot; + arr[0]);&#10;            System.out.println(&quot;中序: &quot; + tree.inorder());&#10;            System.out.println(&quot;前序: &quot; + tree.preorder());&#10;            System.out.println(&quot;後序: &quot; + tree.postorder());&#10;        }&#10;    }&#10;&#10;    // 遞迴計算將被刪除的節點數&#10;    private static void countDelete(Integer[] arr, int idx, int[] count) {&#10;        if (idx &lt;= 0 || idx &gt;= arr.length || arr[idx] == null) return;&#10;        count[0]++;&#10;        countDelete(arr, 2 * idx, count);&#10;        countDelete(arr, 2 * idx + 1, count);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/src/BinaryTreeArrayGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/src/BinaryTreeArrayGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;import java.util.*;&#10;import java.util.stream.IntStream;&#10;&#10;public class BinaryTreeArrayGUI extends JFrame {&#10;    private BinaryTreeArray tree;&#10;    private Integer[] arr;&#10;    private JTextField inputField;&#10;    private JTextField insertIdxField, insertValField;&#10;    private JTextField deleteIdxField;&#10;    private JTextArea outputArea;&#10;    private JLabel nodeCountLabel;&#10;    private TreeVisualizationPanel treePanel;&#10;    private JRadioButton inorderBtn, preorderBtn, postorderBtn;&#10;    private JButton visitBtn;&#10;    private JButton stepBtn, resetBtn;&#10;    private javax.swing.Timer walkTimer;&#10;    private java.util.List&lt;Integer&gt; currentTraversalPath;&#10;&#10;    public BinaryTreeArrayGUI() {&#10;        setTitle(&quot;Binary Tree/Heap 教學系統&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(1000, 800);&#10;        setLayout(new BorderLayout(10, 10));&#10;&#10;        // 設定主要背景色&#10;        getContentPane().setBackground(new Color(248, 249, 250));&#10;&#10;        // 頂部輸入面板&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        topPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;建立二元樹&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        topPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 5, 5, 5);&#10;&#10;        inputField = new JTextField(25);&#10;        inputField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        JButton buildBtn = new JButton(&quot;建立/重設樹&quot;);&#10;        buildBtn.setBackground(new Color(144, 238, 144));  // 淡綠色背景&#10;        buildBtn.setForeground(Color.BLACK);  // 黑色文字&#10;        buildBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;&#10;        JButton autoBtn = new JButton(&quot;自動產生隨機數&quot;);&#10;        autoBtn.setBackground(new Color(144, 238, 144));  // 淡綠色背景&#10;        autoBtn.setForeground(Color.BLACK);  // 黑色文字&#10;        autoBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        JTextField autoNField = new JTextField(5);&#10;        autoNField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;&#10;        gbc.gridx = 0; gbc.gridy = 0;&#10;        topPanel.add(new JLabel(&quot;輸入陣列(逗號分隔, null為空):&quot;), gbc);&#10;        gbc.gridx = 1;&#10;        topPanel.add(inputField, gbc);&#10;        gbc.gridx = 2;&#10;        topPanel.add(buildBtn, gbc);&#10;&#10;        gbc.gridx = 0; gbc.gridy = 1;&#10;        topPanel.add(new JLabel(&quot;或產生 N 個隨機數:&quot;), gbc);&#10;        gbc.gridx = 1;&#10;        topPanel.add(autoNField, gbc);&#10;        gbc.gridx = 2;&#10;        topPanel.add(autoBtn, gbc);&#10;&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        // 中央操作面板&#10;        JPanel centerPanel = new JPanel(new BorderLayout());&#10;&#10;        // 左側操作區&#10;        JPanel leftPanel = new JPanel(new GridBagLayout());&#10;        leftPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;節點操作&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        leftPanel.setBackground(Color.WHITE);&#10;        leftPanel.setPreferredSize(new Dimension(300, 0));&#10;&#10;        GridBagConstraints leftGbc = new GridBagConstraints();&#10;        leftGbc.insets = new Insets(10, 10, 5, 10);&#10;        leftGbc.anchor = GridBagConstraints.WEST;&#10;        leftGbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        // 插入/修改節點區域&#10;        JPanel insertPanel = new JPanel(new GridBagLayout());&#10;        insertPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;插入/修改節點&quot;));&#10;        insertPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints insertGbc = new GridBagConstraints();&#10;        insertGbc.insets = new Insets(5, 5, 5, 5);&#10;        insertGbc.anchor = GridBagConstraints.WEST;&#10;&#10;        insertIdxField = new JTextField(12);&#10;        insertValField = new JTextField(12);&#10;        insertIdxField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        insertValField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        insertIdxField.setHorizontalAlignment(JTextField.LEFT);&#10;        insertValField.setHorizontalAlignment(JTextField.LEFT);&#10;&#10;        JButton insertBtn = new JButton(&quot;插入/修改&quot;);&#10;        insertBtn.setBackground(new Color(144, 238, 144));&#10;        insertBtn.setForeground(Color.BLACK);&#10;        insertBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        insertBtn.setPreferredSize(new Dimension(120, 30));&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 0;&#10;        insertPanel.add(new JLabel(&quot;索引:&quot;), insertGbc);&#10;        insertGbc.gridx = 1;&#10;        insertPanel.add(insertIdxField, insertGbc);&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 1;&#10;        insertPanel.add(new JLabel(&quot;值:&quot;), insertGbc);&#10;        insertGbc.gridx = 1;&#10;        insertPanel.add(insertValField, insertGbc);&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 2; insertGbc.gridwidth = 2;&#10;        insertGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        insertPanel.add(insertBtn, insertGbc);&#10;&#10;        // 刪除節點區域&#10;        JPanel deletePanel = new JPanel(new GridBagLayout());&#10;        deletePanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;刪除節點&quot;));&#10;        deletePanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints deleteGbc = new GridBagConstraints();&#10;        deleteGbc.insets = new Insets(5, 5, 5, 5);&#10;        deleteGbc.anchor = GridBagConstraints.WEST;&#10;&#10;        deleteIdxField = new JTextField(12);&#10;        deleteIdxField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        deleteIdxField.setHorizontalAlignment(JTextField.LEFT);&#10;&#10;        JButton deleteBtn = new JButton(&quot;刪除節點&quot;);&#10;        deleteBtn.setBackground(new Color(144, 238, 144));&#10;        deleteBtn.setForeground(Color.BLACK);&#10;        deleteBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        deleteBtn.setPreferredSize(new Dimension(120, 30));&#10;&#10;        deleteGbc.gridx = 0; deleteGbc.gridy = 0;&#10;        deletePanel.add(new JLabel(&quot;索引:&quot;), deleteGbc);&#10;        deleteGbc.gridx = 1;&#10;        deletePanel.add(deleteIdxField, deleteGbc);&#10;&#10;        deleteGbc.gridx = 0; deleteGbc.gridy = 1; deleteGbc.gridwidth = 2;&#10;        deleteGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        deletePanel.add(deleteBtn, deleteGbc);&#10;&#10;        // 走訪選項區域&#10;        JPanel visitPanel = new JPanel(new GridBagLayout());&#10;        visitPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;樹走訪&quot;));&#10;        visitPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints visitGbc = new GridBagConstraints();&#10;        visitGbc.insets = new Insets(5, 5, 5, 5);&#10;        visitGbc.anchor = GridBagConstraints.WEST;&#10;        visitGbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        inorderBtn = new JRadioButton(&quot;中序 (Inorder)&quot;);&#10;        preorderBtn = new JRadioButton(&quot;前序 (Preorder)&quot;);&#10;        postorderBtn = new JRadioButton(&quot;後序 (Postorder)&quot;);&#10;&#10;        inorderBtn.setBackground(Color.WHITE);&#10;        preorderBtn.setBackground(Color.WHITE);&#10;        postorderBtn.setBackground(Color.WHITE);&#10;&#10;        visitBtn = new JButton(&quot;執行走訪&quot;);&#10;        visitBtn.setBackground(new Color(144, 238, 144));&#10;        visitBtn.setForeground(Color.BLACK);&#10;        visitBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;&#10;        stepBtn = new JButton(&quot;逐步顯示&quot;);&#10;        stepBtn.setBackground(new Color(144, 238, 144));&#10;        stepBtn.setForeground(Color.BLACK);&#10;        stepBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;        stepBtn.setEnabled(false);&#10;&#10;        resetBtn = new JButton(&quot;重置&quot;);&#10;        resetBtn.setBackground(new Color(144, 238, 144));&#10;        resetBtn.setForeground(Color.BLACK);&#10;        resetBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;        resetBtn.setEnabled(false);&#10;&#10;        visitGbc.gridx = 0; visitGbc.gridy = 0; visitGbc.gridwidth = 3;&#10;        visitPanel.add(inorderBtn, visitGbc);&#10;        visitGbc.gridy = 1;&#10;        visitPanel.add(preorderBtn, visitGbc);&#10;        visitGbc.gridy = 2;&#10;        visitPanel.add(postorderBtn, visitGbc);&#10;&#10;        // 控制按鈕區域&#10;        JPanel controlPanel = new JPanel(new GridLayout(1, 3, 3, 3));&#10;        controlPanel.setBackground(Color.WHITE);&#10;        controlPanel.add(visitBtn);&#10;        controlPanel.add(stepBtn);&#10;        controlPanel.add(resetBtn);&#10;&#10;        visitGbc.gridy = 3; visitGbc.insets = new Insets(10, 5, 5, 5);&#10;        visitPanel.add(controlPanel, visitGbc);&#10;&#10;        // 將各個面板添加到左側主面板&#10;        leftGbc.gridx = 0; leftGbc.gridy = 0; leftGbc.weightx = 1.0;&#10;        leftPanel.add(insertPanel, leftGbc);&#10;&#10;        leftGbc.gridy = 1; leftGbc.insets = new Insets(5, 10, 5, 10);&#10;        leftPanel.add(deletePanel, leftGbc);&#10;&#10;        leftGbc.gridy = 2; leftGbc.weighty = 1.0;&#10;        leftPanel.add(visitPanel, leftGbc);&#10;&#10;        centerPanel.add(leftPanel, BorderLayout.WEST);&#10;&#10;        // 右側樹狀顯示區&#10;        JPanel rightPanel = new JPanel(new BorderLayout());&#10;        rightPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;樹狀結構視覺化&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        rightPanel.setBackground(Color.WHITE);&#10;&#10;        treePanel = new TreeVisualizationPanel();&#10;        rightPanel.add(treePanel, BorderLayout.CENTER);&#10;&#10;        centerPanel.add(rightPanel, BorderLayout.CENTER);&#10;        add(centerPanel, BorderLayout.CENTER);&#10;&#10;        // 底部資訊面板&#10;        JPanel bottomPanel = new JPanel(new BorderLayout());&#10;&#10;        // 節點數顯示&#10;        JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        infoPanel.setBackground(new Color(248, 249, 250));&#10;        nodeCountLabel = new JLabel(&quot;節點數: 0&quot;);&#10;        nodeCountLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 14));&#10;        nodeCountLabel.setForeground(new Color(0, 123, 255));&#10;        infoPanel.add(nodeCountLabel);&#10;        bottomPanel.add(infoPanel, BorderLayout.NORTH);&#10;&#10;        // 輸出結果區&#10;        JPanel outputPanel = new JPanel(new BorderLayout());&#10;        outputPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;走訪結果&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        outputPanel.setBackground(Color.WHITE);&#10;&#10;        outputArea = new JTextArea(6, 80);&#10;        outputArea.setEditable(false);&#10;        outputArea.setFont(new Font(&quot;Courier New&quot;, Font.PLAIN, 12));&#10;        outputArea.setBackground(new Color(248, 249, 250));&#10;        outputArea.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));&#10;        outputPanel.add(new JScrollPane(outputArea), BorderLayout.CENTER);&#10;&#10;        bottomPanel.add(outputPanel, BorderLayout.CENTER);&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;&#10;        // 事件處理&#10;        buildBtn.addActionListener(e -&gt; buildTreeFromInput());&#10;        autoBtn.addActionListener(e -&gt; buildTreeAuto(autoNField.getText()));&#10;        insertBtn.addActionListener(e -&gt; insertNode());&#10;        deleteBtn.addActionListener(e -&gt; deleteNode());&#10;        visitBtn.addActionListener(e -&gt; visitTree());&#10;        stepBtn.addActionListener(e -&gt; stepTraversal());&#10;        resetBtn.addActionListener(e -&gt; resetTraversal());&#10;&#10;        // 初始化 Timer&#10;        walkTimer = new javax.swing.Timer(800, e -&gt; {&#10;            if (treePanel.hasMoreSteps()) {&#10;                treePanel.showNextVisitStep();&#10;            } else {&#10;                walkTimer.stop();&#10;                stepBtn.setEnabled(false);&#10;            }&#10;        });&#10;&#10;        // 設定視窗居中&#10;        setLocationRelativeTo(null);&#10;    }&#10;&#10;    private void buildTreeFromInput() {&#10;        String input = inputField.getText().trim();&#10;        arr = BinaryTreeArray.parseInput(input);&#10;        tree = new BinaryTreeArray(arr);&#10;        outputArea.setText(&quot;建立樹的陣列參數: &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void buildTreeAuto(String nStr) {&#10;        int n;&#10;        try {&#10;            n = Integer.parseInt(nStr.trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入正整數N&quot;);&#10;            return;&#10;        }&#10;        if (n &lt;= 0) {&#10;            JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;            return;&#10;        }&#10;        Set&lt;Integer&gt; nums = new LinkedHashSet&lt;&gt;();&#10;        Random rand = new Random();&#10;        while (nums.size() &lt; n) nums.add(rand.nextInt(10000));&#10;        arr = new Integer[n + 1];&#10;        arr[0] = n;&#10;        int i = 1;&#10;        for (int num : nums) arr[i++] = num;&#10;        tree = new BinaryTreeArray(arr);&#10;        inputField.setText(&quot;&quot;);&#10;        outputArea.setText(&quot;建立樹的陣列參數: &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void insertNode() {&#10;        if (arr == null) return;&#10;        int idx;&#10;        try {&#10;            idx = Integer.parseInt(insertIdxField.getText().trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入索引&quot;);&#10;            return;&#10;        }&#10;        String valStr = insertValField.getText().trim();&#10;        Integer val = valStr.equalsIgnoreCase(&quot;null&quot;) ? null : null;&#10;        if (!valStr.equalsIgnoreCase(&quot;null&quot;)) {&#10;            try {&#10;                val = Integer.parseInt(valStr);&#10;            } catch (Exception e) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入整數或null&quot;);&#10;                return;&#10;            }&#10;        }&#10;        if (idx &gt; 0 &amp;&amp; idx &lt; arr.length) {&#10;            if (arr[idx] == null &amp;&amp; val != null) arr[0]++;&#10;            if (arr[idx] != null &amp;&amp; val == null) arr[0]--;&#10;            arr[idx] = val;&#10;            tree = new BinaryTreeArray(arr);&#10;            updateDisplay(false);&#10;        } else {&#10;            JOptionPane.showMessageDialog(this, &quot;索引超出範圍&quot;);&#10;        }&#10;    }&#10;&#10;    private void deleteNode() {&#10;        if (arr == null) return;&#10;        int idx;&#10;        try {&#10;            idx = Integer.parseInt(deleteIdxField.getText().trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入索引&quot;);&#10;            return;&#10;        }&#10;        int[] delCount = new int[]{0};&#10;        countDelete(arr, idx, delCount);&#10;        tree.delete(idx);&#10;        arr[0] -= delCount[0];&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void updateDisplay(boolean showTraversal) {&#10;        if (arr == null) return;&#10;        nodeCountLabel.setText(&quot;節點數: &quot; + arr[0]);&#10;&#10;        // 更新樹狀視覺化&#10;        treePanel.setTreeArray(arr);&#10;&#10;        if (tree != null &amp;&amp; showTraversal) {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderBtn.isSelected()) {&#10;                sb.append(&quot;中序: &quot;).append(tree.inorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (preorderBtn.isSelected()) {&#10;                sb.append(&quot;前序: &quot;).append(tree.preorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (postorderBtn.isSelected()) {&#10;                sb.append(&quot;後序: &quot;).append(tree.postorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (sb.length() == 0) {&#10;                sb.append(&quot;請至少選擇一種走訪方式&quot;);&#10;            }&#10;            outputArea.setText(sb.toString());&#10;        }&#10;    }&#10;&#10;    // 遞迴計算將被刪除的節點數&#10;    private static void countDelete(Integer[] arr, int idx, int[] count) {&#10;        if (idx &lt;= 0 || idx &gt;= arr.length || arr[idx] == null) return;&#10;        count[0]++;&#10;        countDelete(arr, 2 * idx, count);&#10;        countDelete(arr, 2 * idx + 1, count);&#10;    }&#10;&#10;    private void visitTree() {&#10;        if (tree == null) return;&#10;&#10;        currentTraversalPath = new ArrayList&lt;&gt;();&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        if (inorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; inorderResult = tree.inorder();&#10;            currentTraversalPath.addAll(inorderResult);&#10;            sb.append(&quot;中序: &quot;).append(inorderResult).append(&quot;\n&quot;);&#10;        }&#10;        if (preorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; preorderResult = tree.preorder();&#10;            if (!inorderBtn.isSelected()) currentTraversalPath.addAll(preorderResult);&#10;            sb.append(&quot;前序: &quot;).append(preorderResult).append(&quot;\n&quot;);&#10;        }&#10;        if (postorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; postorderResult = tree.postorder();&#10;            if (!inorderBtn.isSelected() &amp;&amp; !preorderBtn.isSelected()) currentTraversalPath.addAll(postorderResult);&#10;            sb.append(&quot;後序: &quot;).append(postorderResult).append(&quot;\n&quot;);&#10;        }&#10;&#10;        if (sb.length() == 0) {&#10;            sb.append(&quot;請至少選擇一種走訪方式&quot;);&#10;            outputArea.setText(sb.toString());&#10;            return;&#10;        }&#10;&#10;        // 設定走訪路徑到視覺化面板&#10;        treePanel.setVisitPath(currentTraversalPath);&#10;        outputArea.setText(sb.toString());&#10;&#10;        // 啟用控制按鈕&#10;        stepBtn.setEnabled(true);&#10;        resetBtn.setEnabled(true);&#10;    }&#10;&#10;    private void stepTraversal() {&#10;        if (currentTraversalPath != null &amp;&amp; !currentTraversalPath.isEmpty()) {&#10;            if (treePanel.hasMoreSteps()) {&#10;                treePanel.showNextVisitStep();&#10;                if (!treePanel.hasMoreSteps()) {&#10;                    stepBtn.setEnabled(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void resetTraversal() {&#10;        if (walkTimer.isRunning()) {&#10;            walkTimer.stop();&#10;        }&#10;        treePanel.clearVisitPath();&#10;        stepBtn.setEnabled(currentTraversalPath != null &amp;&amp; !currentTraversalPath.isEmpty());&#10;        resetBtn.setEnabled(false);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            BinaryTreeArrayGUI gui = new BinaryTreeArrayGUI();&#10;            gui.setVisible(true);&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;import java.util.*;&#10;import java.util.stream.IntStream;&#10;&#10;public class BinaryTreeArrayGUI extends JFrame {&#10;    private BinaryTreeArray tree;&#10;    private Integer[] arr;&#10;    private JTextField inputField;&#10;    private JTextField insertIdxField, insertValField;&#10;    private JTextField deleteIdxField;&#10;    private JTextArea outputArea;&#10;    private JLabel nodeCountLabel;&#10;    private TreeVisualizationPanel treePanel;&#10;    private JRadioButton inorderBtn, preorderBtn, postorderBtn;&#10;    private JButton visitBtn;&#10;    private JButton stepBtn, resetBtn;&#10;    private javax.swing.Timer walkTimer;&#10;    private java.util.List&lt;Integer&gt; currentTraversalPath;&#10;&#10;    public BinaryTreeArrayGUI() {&#10;        setTitle(&quot;Binary Tree/Heap 教學系統&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(1000, 800);&#10;        setLayout(new BorderLayout(10, 10));&#10;&#10;        // 設定主要背景色&#10;        getContentPane().setBackground(new Color(248, 249, 250));&#10;&#10;        // 頂部輸入面板&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        topPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;建立二元樹&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        topPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 5, 5, 5);&#10;&#10;        inputField = new JTextField(25);&#10;        inputField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        JButton buildBtn = new JButton(&quot;建立/重設樹&quot;);&#10;        buildBtn.setBackground(new Color(144, 238, 144));  // 淡綠色背景&#10;        buildBtn.setForeground(Color.BLACK);  // 黑色文字&#10;        buildBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;&#10;        JButton autoBtn = new JButton(&quot;自動產生隨機數&quot;);&#10;        autoBtn.setBackground(new Color(144, 238, 144));  // 淡綠色背景&#10;        autoBtn.setForeground(Color.BLACK);  // 黑色文字&#10;        autoBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        JTextField autoNField = new JTextField(5);&#10;        autoNField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;&#10;        gbc.gridx = 0; gbc.gridy = 0;&#10;        topPanel.add(new JLabel(&quot;輸入陣列(逗號分隔, null為空):&quot;), gbc);&#10;        gbc.gridx = 1;&#10;        topPanel.add(inputField, gbc);&#10;        gbc.gridx = 2;&#10;        topPanel.add(buildBtn, gbc);&#10;&#10;        gbc.gridx = 0; gbc.gridy = 1;&#10;        topPanel.add(new JLabel(&quot;或產生 N 個隨機數:&quot;), gbc);&#10;        gbc.gridx = 1;&#10;        topPanel.add(autoNField, gbc);&#10;        gbc.gridx = 2;&#10;        topPanel.add(autoBtn, gbc);&#10;&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        // 中央操作面板&#10;        JPanel centerPanel = new JPanel(new BorderLayout());&#10;&#10;        // 左側操作區&#10;        JPanel leftPanel = new JPanel(new GridBagLayout());&#10;        leftPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;節點操作&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        leftPanel.setBackground(Color.WHITE);&#10;        leftPanel.setPreferredSize(new Dimension(300, 0));&#10;&#10;        GridBagConstraints leftGbc = new GridBagConstraints();&#10;        leftGbc.insets = new Insets(10, 10, 5, 10);&#10;        leftGbc.anchor = GridBagConstraints.WEST;&#10;        leftGbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        // 插入/修改節點區域&#10;        JPanel insertPanel = new JPanel(new GridBagLayout());&#10;        insertPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;插入/修改節點&quot;));&#10;        insertPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints insertGbc = new GridBagConstraints();&#10;        insertGbc.insets = new Insets(8, 8, 8, 8);&#10;        insertGbc.anchor = GridBagConstraints.WEST;&#10;&#10;        insertIdxField = new JTextField(15);&#10;        insertValField = new JTextField(15);&#10;        insertIdxField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 14));&#10;        insertValField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 14));&#10;        insertIdxField.setHorizontalAlignment(JTextField.LEFT);&#10;        insertValField.setHorizontalAlignment(JTextField.LEFT);&#10;        &#10;        // 設定較大的首選大小&#10;        insertIdxField.setPreferredSize(new Dimension(150, 28));&#10;        insertValField.setPreferredSize(new Dimension(150, 28));&#10;&#10;        JButton insertBtn = new JButton(&quot;插入/修改&quot;);&#10;        insertBtn.setBackground(new Color(144, 238, 144));&#10;        insertBtn.setForeground(Color.BLACK);&#10;        insertBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        insertBtn.setPreferredSize(new Dimension(140, 32));&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 0;&#10;        insertPanel.add(new JLabel(&quot;索引:&quot;), insertGbc);&#10;        insertGbc.gridx = 1; insertGbc.weightx = 1.0; insertGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        insertPanel.add(insertIdxField, insertGbc);&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 1; insertGbc.weightx = 0.0; insertGbc.fill = GridBagConstraints.NONE;&#10;        insertPanel.add(new JLabel(&quot;值:&quot;), insertGbc);&#10;        insertGbc.gridx = 1; insertGbc.weightx = 1.0; insertGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        insertPanel.add(insertValField, insertGbc);&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 2; insertGbc.gridwidth = 2; insertGbc.weightx = 0.0;&#10;        insertGbc.fill = GridBagConstraints.HORIZONTAL; insertGbc.insets = new Insets(12, 8, 8, 8);&#10;        insertPanel.add(insertBtn, insertGbc);&#10;&#10;        // 刪除節點區域&#10;        JPanel deletePanel = new JPanel(new GridBagLayout());&#10;        deletePanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;刪除節點&quot;));&#10;        deletePanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints deleteGbc = new GridBagConstraints();&#10;        deleteGbc.insets = new Insets(8, 8, 8, 8);&#10;        deleteGbc.anchor = GridBagConstraints.WEST;&#10;&#10;        deleteIdxField = new JTextField(15);&#10;        deleteIdxField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 14));&#10;        deleteIdxField.setHorizontalAlignment(JTextField.LEFT);&#10;        deleteIdxField.setPreferredSize(new Dimension(150, 28));&#10;&#10;        JButton deleteBtn = new JButton(&quot;刪除節點&quot;);&#10;        deleteBtn.setBackground(new Color(144, 238, 144));&#10;        deleteBtn.setForeground(Color.BLACK);&#10;        deleteBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        deleteBtn.setPreferredSize(new Dimension(140, 32));&#10;&#10;        deleteGbc.gridx = 0; deleteGbc.gridy = 0;&#10;        deletePanel.add(new JLabel(&quot;索引:&quot;), deleteGbc);&#10;        deleteGbc.gridx = 1; deleteGbc.weightx = 1.0; deleteGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        deletePanel.add(deleteIdxField, deleteGbc);&#10;&#10;        deleteGbc.gridx = 0; deleteGbc.gridy = 1; deleteGbc.gridwidth = 2; deleteGbc.weightx = 0.0;&#10;        deleteGbc.fill = GridBagConstraints.HORIZONTAL; deleteGbc.insets = new Insets(12, 8, 8, 8);&#10;        deletePanel.add(deleteBtn, deleteGbc);&#10;&#10;        // 走訪選項區域&#10;        JPanel visitPanel = new JPanel(new GridBagLayout());&#10;        visitPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;樹走訪&quot;));&#10;        visitPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints visitGbc = new GridBagConstraints();&#10;        visitGbc.insets = new Insets(5, 5, 5, 5);&#10;        visitGbc.anchor = GridBagConstraints.WEST;&#10;        visitGbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        inorderBtn = new JRadioButton(&quot;中序 (Inorder)&quot;);&#10;        preorderBtn = new JRadioButton(&quot;前序 (Preorder)&quot;);&#10;        postorderBtn = new JRadioButton(&quot;後序 (Postorder)&quot;);&#10;&#10;        inorderBtn.setBackground(Color.WHITE);&#10;        preorderBtn.setBackground(Color.WHITE);&#10;        postorderBtn.setBackground(Color.WHITE);&#10;&#10;        visitBtn = new JButton(&quot;執行走訪&quot;);&#10;        visitBtn.setBackground(new Color(144, 238, 144));&#10;        visitBtn.setForeground(Color.BLACK);&#10;        visitBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;&#10;        stepBtn = new JButton(&quot;逐步顯示&quot;);&#10;        stepBtn.setBackground(new Color(144, 238, 144));&#10;        stepBtn.setForeground(Color.BLACK);&#10;        stepBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;        stepBtn.setEnabled(false);&#10;&#10;        resetBtn = new JButton(&quot;重置&quot;);&#10;        resetBtn.setBackground(new Color(144, 238, 144));&#10;        resetBtn.setForeground(Color.BLACK);&#10;        resetBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;        resetBtn.setEnabled(false);&#10;&#10;        visitGbc.gridx = 0; visitGbc.gridy = 0; visitGbc.gridwidth = 3;&#10;        visitPanel.add(inorderBtn, visitGbc);&#10;        visitGbc.gridy = 1;&#10;        visitPanel.add(preorderBtn, visitGbc);&#10;        visitGbc.gridy = 2;&#10;        visitPanel.add(postorderBtn, visitGbc);&#10;&#10;        // 控制按鈕區域&#10;        JPanel controlPanel = new JPanel(new GridLayout(1, 3, 3, 3));&#10;        controlPanel.setBackground(Color.WHITE);&#10;        controlPanel.add(visitBtn);&#10;        controlPanel.add(stepBtn);&#10;        controlPanel.add(resetBtn);&#10;&#10;        visitGbc.gridy = 3; visitGbc.insets = new Insets(10, 5, 5, 5);&#10;        visitPanel.add(controlPanel, visitGbc);&#10;&#10;        // 將各個面板添加到左側主面板&#10;        leftGbc.gridx = 0; leftGbc.gridy = 0; leftGbc.weightx = 1.0;&#10;        leftPanel.add(insertPanel, leftGbc);&#10;&#10;        leftGbc.gridy = 1; leftGbc.insets = new Insets(5, 10, 5, 10);&#10;        leftPanel.add(deletePanel, leftGbc);&#10;&#10;        leftGbc.gridy = 2; leftGbc.weighty = 1.0;&#10;        leftPanel.add(visitPanel, leftGbc);&#10;&#10;        centerPanel.add(leftPanel, BorderLayout.WEST);&#10;&#10;        // 右側樹狀顯示區&#10;        JPanel rightPanel = new JPanel(new BorderLayout());&#10;        rightPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;樹狀結構視覺化&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        rightPanel.setBackground(Color.WHITE);&#10;&#10;        treePanel = new TreeVisualizationPanel();&#10;        rightPanel.add(treePanel, BorderLayout.CENTER);&#10;&#10;        centerPanel.add(rightPanel, BorderLayout.CENTER);&#10;        add(centerPanel, BorderLayout.CENTER);&#10;&#10;        // 底部資訊面板&#10;        JPanel bottomPanel = new JPanel(new BorderLayout());&#10;&#10;        // 節點數顯示&#10;        JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        infoPanel.setBackground(new Color(248, 249, 250));&#10;        nodeCountLabel = new JLabel(&quot;節點數: 0&quot;);&#10;        nodeCountLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 14));&#10;        nodeCountLabel.setForeground(new Color(0, 123, 255));&#10;        infoPanel.add(nodeCountLabel);&#10;        bottomPanel.add(infoPanel, BorderLayout.NORTH);&#10;&#10;        // 輸出結果區&#10;        JPanel outputPanel = new JPanel(new BorderLayout());&#10;        outputPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;走訪結果&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        outputPanel.setBackground(Color.WHITE);&#10;&#10;        outputArea = new JTextArea(6, 80);&#10;        outputArea.setEditable(false);&#10;        outputArea.setFont(new Font(&quot;Courier New&quot;, Font.PLAIN, 12));&#10;        outputArea.setBackground(new Color(248, 249, 250));&#10;        outputArea.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));&#10;        outputPanel.add(new JScrollPane(outputArea), BorderLayout.CENTER);&#10;&#10;        bottomPanel.add(outputPanel, BorderLayout.CENTER);&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;&#10;        // 事件處理&#10;        buildBtn.addActionListener(e -&gt; buildTreeFromInput());&#10;        autoBtn.addActionListener(e -&gt; buildTreeAuto(autoNField.getText()));&#10;        insertBtn.addActionListener(e -&gt; insertNode());&#10;        deleteBtn.addActionListener(e -&gt; deleteNode());&#10;        visitBtn.addActionListener(e -&gt; visitTree());&#10;        stepBtn.addActionListener(e -&gt; stepTraversal());&#10;        resetBtn.addActionListener(e -&gt; resetTraversal());&#10;&#10;        // 初始化 Timer&#10;        walkTimer = new javax.swing.Timer(800, e -&gt; {&#10;            if (treePanel.hasMoreSteps()) {&#10;                treePanel.showNextVisitStep();&#10;            } else {&#10;                walkTimer.stop();&#10;                stepBtn.setEnabled(false);&#10;            }&#10;        });&#10;&#10;        // 設定視窗居中&#10;        setLocationRelativeTo(null);&#10;    }&#10;&#10;    private void buildTreeFromInput() {&#10;        String input = inputField.getText().trim();&#10;        arr = BinaryTreeArray.parseInput(input);&#10;        tree = new BinaryTreeArray(arr);&#10;        outputArea.setText(&quot;建立樹的陣列參數: &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void buildTreeAuto(String nStr) {&#10;        int n;&#10;        try {&#10;            n = Integer.parseInt(nStr.trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入正整數N&quot;);&#10;            return;&#10;        }&#10;        if (n &lt;= 0) {&#10;            JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;            return;&#10;        }&#10;        Set&lt;Integer&gt; nums = new LinkedHashSet&lt;&gt;();&#10;        Random rand = new Random();&#10;        while (nums.size() &lt; n) nums.add(rand.nextInt(10000));&#10;        arr = new Integer[n + 1];&#10;        arr[0] = n;&#10;        int i = 1;&#10;        for (int num : nums) arr[i++] = num;&#10;        tree = new BinaryTreeArray(arr);&#10;        inputField.setText(&quot;&quot;);&#10;        outputArea.setText(&quot;建立樹的陣列參數: &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void insertNode() {&#10;        if (arr == null) return;&#10;        int idx;&#10;        try {&#10;            idx = Integer.parseInt(insertIdxField.getText().trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入索引&quot;);&#10;            return;&#10;        }&#10;        String valStr = insertValField.getText().trim();&#10;        Integer val = valStr.equalsIgnoreCase(&quot;null&quot;) ? null : null;&#10;        if (!valStr.equalsIgnoreCase(&quot;null&quot;)) {&#10;            try {&#10;                val = Integer.parseInt(valStr);&#10;            } catch (Exception e) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入整數或null&quot;);&#10;                return;&#10;            }&#10;        }&#10;        if (idx &gt; 0 &amp;&amp; idx &lt; arr.length) {&#10;            if (arr[idx] == null &amp;&amp; val != null) arr[0]++;&#10;            if (arr[idx] != null &amp;&amp; val == null) arr[0]--;&#10;            arr[idx] = val;&#10;            tree = new BinaryTreeArray(arr);&#10;            updateDisplay(false);&#10;        } else {&#10;            JOptionPane.showMessageDialog(this, &quot;索引超出範圍&quot;);&#10;        }&#10;    }&#10;&#10;    private void deleteNode() {&#10;        if (arr == null) return;&#10;        int idx;&#10;        try {&#10;            idx = Integer.parseInt(deleteIdxField.getText().trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入索引&quot;);&#10;            return;&#10;        }&#10;        int[] delCount = new int[]{0};&#10;        countDelete(arr, idx, delCount);&#10;        tree.delete(idx);&#10;        arr[0] -= delCount[0];&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void updateDisplay(boolean showTraversal) {&#10;        if (arr == null) return;&#10;        nodeCountLabel.setText(&quot;節點數: &quot; + arr[0]);&#10;&#10;        // 更新樹狀視覺化&#10;        treePanel.setTreeArray(arr);&#10;&#10;        if (tree != null &amp;&amp; showTraversal) {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderBtn.isSelected()) {&#10;                sb.append(&quot;中序: &quot;).append(tree.inorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (preorderBtn.isSelected()) {&#10;                sb.append(&quot;前序: &quot;).append(tree.preorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (postorderBtn.isSelected()) {&#10;                sb.append(&quot;後序: &quot;).append(tree.postorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (sb.length() == 0) {&#10;                sb.append(&quot;請至少選擇一種走訪方式&quot;);&#10;            }&#10;            outputArea.setText(sb.toString());&#10;        }&#10;    }&#10;&#10;    // 遞迴計算將被刪除的節點數&#10;    private static void countDelete(Integer[] arr, int idx, int[] count) {&#10;        if (idx &lt;= 0 || idx &gt;= arr.length || arr[idx] == null) return;&#10;        count[0]++;&#10;        countDelete(arr, 2 * idx, count);&#10;        countDelete(arr, 2 * idx + 1, count);&#10;    }&#10;&#10;    private void visitTree() {&#10;        if (tree == null) return;&#10;&#10;        currentTraversalPath = new ArrayList&lt;&gt;();&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        if (inorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; inorderResult = tree.inorder();&#10;            currentTraversalPath.addAll(inorderResult);&#10;            sb.append(&quot;中序: &quot;).append(inorderResult).append(&quot;\n&quot;);&#10;        }&#10;        if (preorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; preorderResult = tree.preorder();&#10;            if (!inorderBtn.isSelected()) currentTraversalPath.addAll(preorderResult);&#10;            sb.append(&quot;前序: &quot;).append(preorderResult).append(&quot;\n&quot;);&#10;        }&#10;        if (postorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; postorderResult = tree.postorder();&#10;            if (!inorderBtn.isSelected() &amp;&amp; !preorderBtn.isSelected()) currentTraversalPath.addAll(postorderResult);&#10;            sb.append(&quot;後序: &quot;).append(postorderResult).append(&quot;\n&quot;);&#10;        }&#10;&#10;        if (sb.length() == 0) {&#10;            sb.append(&quot;請至少選擇一種走訪方式&quot;);&#10;            outputArea.setText(sb.toString());&#10;            return;&#10;        }&#10;&#10;        // 設定走訪路徑到視覺化面板&#10;        treePanel.setVisitPath(currentTraversalPath);&#10;        outputArea.setText(sb.toString());&#10;&#10;        // 啟用控制按鈕&#10;        stepBtn.setEnabled(true);&#10;        resetBtn.setEnabled(true);&#10;    }&#10;&#10;    private void stepTraversal() {&#10;        if (currentTraversalPath != null &amp;&amp; !currentTraversalPath.isEmpty()) {&#10;            if (treePanel.hasMoreSteps()) {&#10;                treePanel.showNextVisitStep();&#10;                if (!treePanel.hasMoreSteps()) {&#10;                    stepBtn.setEnabled(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void resetTraversal() {&#10;        if (walkTimer.isRunning()) {&#10;            walkTimer.stop();&#10;        }&#10;        treePanel.clearVisitPath();&#10;        stepBtn.setEnabled(currentTraversalPath != null &amp;&amp; !currentTraversalPath.isEmpty());&#10;        resetBtn.setEnabled(false);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            BinaryTreeArrayGUI gui = new BinaryTreeArrayGUI();&#10;            gui.setVisible(true);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/src/TreeVisualizationPanel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/src/TreeVisualizationPanel.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.geom.Ellipse2D;&#10;import java.awt.geom.Line2D;&#10;import java.util.ArrayList;&#10;&#10;public class TreeVisualizationPanel extends JPanel {&#10;    private Integer[] treeArray;&#10;    private java.util.List&lt;Integer&gt; visitPath;&#10;    private int currentVisitIndex;&#10;    private static final int NODE_RADIUS = 20;&#10;    private static final int LEVEL_HEIGHT = 80;&#10;    private static final int MIN_HORIZONTAL_SPACING = 50;&#10;&#10;    public TreeVisualizationPanel() {&#10;        setBackground(new Color(248, 249, 250));&#10;        setPreferredSize(new Dimension(600, 400));&#10;        visitPath = new ArrayList&lt;&gt;();&#10;        currentVisitIndex = -1;&#10;    }&#10;&#10;    public void setTreeArray(Integer[] arr) {&#10;        this.treeArray = arr;&#10;        clearVisitPath();&#10;        repaint();&#10;    }&#10;&#10;    public void setVisitPath(java.util.List&lt;Integer&gt; path) {&#10;        this.visitPath = path;&#10;        this.currentVisitIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    public void showNextVisitStep() {&#10;        if (currentVisitIndex &lt; visitPath.size() - 1) {&#10;            currentVisitIndex++;&#10;            repaint();&#10;        }&#10;    }&#10;&#10;    public void clearVisitPath() {&#10;        this.visitPath.clear();&#10;        this.currentVisitIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    public boolean hasMoreSteps() {&#10;        return currentVisitIndex &lt; visitPath.size() - 1;&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        if (treeArray == null || treeArray.length &lt;= 1) return;&#10;&#10;        Graphics2D g2d = (Graphics2D) g.create();&#10;        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;&#10;        // 計算樹的最大層數&#10;        int maxLevel = (int) (Math.log(treeArray.length - 1) / Math.log(2)) + 1;&#10;&#10;        // 先畫連接線，再畫節點（避免線條覆蓋節點）&#10;        drawConnections(g2d, maxLevel);&#10;        drawNodes(g2d, maxLevel);&#10;&#10;        g2d.dispose();&#10;    }&#10;&#10;    private void drawConnections(Graphics2D g2d, int maxLevel) {&#10;        g2d.setColor(Color.BLACK);&#10;        g2d.setStroke(new BasicStroke(2));&#10;&#10;        for (int i = 1; i &lt; treeArray.length; i++) {&#10;            if (treeArray[i] == null) continue;&#10;&#10;            int leftChild = 2 * i;&#10;            int rightChild = 2 * i + 1;&#10;&#10;            Point parentPos = getNodePosition(i, maxLevel);&#10;&#10;            // 畫左子節點連線&#10;            if (leftChild &lt; treeArray.length &amp;&amp; treeArray[leftChild] != null) {&#10;                Point leftPos = getNodePosition(leftChild, maxLevel);&#10;                g2d.draw(new Line2D.Double(parentPos.x, parentPos.y, leftPos.x, leftPos.y));&#10;            }&#10;&#10;            // 畫右子節點連線&#10;            if (rightChild &lt; treeArray.length &amp;&amp; treeArray[rightChild] != null) {&#10;                Point rightPos = getNodePosition(rightChild, maxLevel);&#10;                g2d.draw(new Line2D.Double(parentPos.x, parentPos.y, rightPos.x, rightPos.y));&#10;            }&#10;        }&#10;    }&#10;&#10;    private void drawNodes(Graphics2D g2d, int maxLevel) {&#10;        for (int i = 1; i &lt; treeArray.length; i++) {&#10;            if (treeArray[i] == null) continue;&#10;&#10;            Point pos = getNodePosition(i, maxLevel);&#10;            boolean isRoot = (i == 1);&#10;            boolean isLeaf = isLeafNode(i);&#10;            boolean isCurrentVisit = currentVisitIndex &gt;= 0 &amp;&amp; currentVisitIndex &lt; visitPath.size()&#10;                                   &amp;&amp; visitPath.get(currentVisitIndex).equals(treeArray[i]);&#10;            boolean isVisited = isNodeVisited(treeArray[i]);&#10;&#10;            // 設定節點顏色&#10;            if (isCurrentVisit) {&#10;                g2d.setColor(new Color(255, 215, 0));  // 當前走訪節點：金黃色&#10;            } else if (isVisited) {&#10;                g2d.setColor(new Color(144, 238, 144));  // 已走訪節點：淡綠色&#10;            } else if (isRoot) {&#10;                g2d.setColor(Color.BLACK);  // 根節點黑色背景&#10;            } else if (isLeaf) {&#10;                g2d.setColor(Color.WHITE);  // 葉節點白色背景&#10;            } else {&#10;                g2d.setColor(new Color(200, 200, 200));  // 中間節點灰色背景&#10;            }&#10;&#10;            // 畫節點圓圈&#10;            Ellipse2D circle = new Ellipse2D.Double(&#10;                pos.x - NODE_RADIUS, pos.y - NODE_RADIUS,&#10;                2 * NODE_RADIUS, 2 * NODE_RADIUS&#10;            );&#10;            g2d.fill(circle);&#10;&#10;            // 畫節點邊框&#10;            if (isCurrentVisit) {&#10;                g2d.setColor(new Color(255, 140, 0));  // 當前節點橙色邊框&#10;                g2d.setStroke(new BasicStroke(4));&#10;            } else {&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;            }&#10;            g2d.draw(circle);&#10;&#10;            // 設定文字顏色&#10;            if (isRoot &amp;&amp; !isCurrentVisit &amp;&amp; !isVisited) {&#10;                g2d.setColor(Color.WHITE);  // 根節點白色文字&#10;            } else {&#10;                g2d.setColor(Color.BLACK);  // 其他節點黑色文字&#10;            }&#10;&#10;            // 畫節點值&#10;            String text = treeArray[i].toString();&#10;            FontMetrics fm = g2d.getFontMetrics();&#10;            int textWidth = fm.stringWidth(text);&#10;            int textHeight = fm.getAscent();&#10;            g2d.drawString(text,&#10;                pos.x - textWidth / 2,&#10;                pos.y + textHeight / 2 - 2);&#10;        }&#10;    }&#10;&#10;    private boolean isNodeVisited(Integer value) {&#10;        for (int i = 0; i &lt;= currentVisitIndex &amp;&amp; i &lt; visitPath.size(); i++) {&#10;            if (visitPath.get(i).equals(value)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private Point getNodePosition(int index, int maxLevel) {&#10;        int level = (int) (Math.log(index) / Math.log(2));&#10;        int nodesInLevel = 1 &lt;&lt; level;&#10;        int positionInLevel = index - (1 &lt;&lt; level);&#10;&#10;        int panelWidth = getWidth();&#10;        int panelHeight = getHeight();&#10;&#10;        // 計算水平位置&#10;        int totalWidth = panelWidth - 2 * NODE_RADIUS;&#10;        int spacing = Math.max(MIN_HORIZONTAL_SPACING, totalWidth / (nodesInLevel + 1));&#10;        int x = NODE_RADIUS + spacing * (positionInLevel + 1);&#10;&#10;        // 確保節點在面板範圍內&#10;        if (nodesInLevel &gt; 1) {&#10;            x = NODE_RADIUS + (totalWidth * (positionInLevel + 1)) / (nodesInLevel + 1);&#10;        } else {&#10;            x = panelWidth / 2;&#10;        }&#10;&#10;        // 計算垂直位置&#10;        int y = NODE_RADIUS + 30 + level * LEVEL_HEIGHT;&#10;&#10;        return new Point(x, y);&#10;    }&#10;&#10;    private boolean isLeafNode(int index) {&#10;        int leftChild = 2 * index;&#10;        int rightChild = 2 * index + 1;&#10;&#10;        boolean hasLeftChild = leftChild &lt; treeArray.length &amp;&amp; treeArray[leftChild] != null;&#10;        boolean hasRightChild = rightChild &lt; treeArray.length &amp;&amp; treeArray[rightChild] != null;&#10;&#10;        return !hasLeftChild &amp;&amp; !hasRightChild;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.geom.Ellipse2D;&#10;import java.awt.geom.Line2D;&#10;import java.util.ArrayList;&#10;&#10;public class TreeVisualizationPanel extends JPanel {&#10;    private Integer[] treeArray;&#10;    private java.util.List&lt;Integer&gt; visitPath;&#10;    private int currentVisitIndex;&#10;    private static final int NODE_RADIUS = 20;&#10;    private static final int LEVEL_HEIGHT = 80;&#10;    private static final int MIN_HORIZONTAL_SPACING = 50;&#10;&#10;    public TreeVisualizationPanel() {&#10;        setBackground(new Color(248, 249, 250));&#10;        setPreferredSize(new Dimension(600, 400));&#10;        visitPath = new ArrayList&lt;&gt;();&#10;        currentVisitIndex = -1;&#10;    }&#10;&#10;    public void setTreeArray(Integer[] arr) {&#10;        this.treeArray = arr;&#10;        clearVisitPath();&#10;        repaint();&#10;    }&#10;&#10;    public void setVisitPath(java.util.List&lt;Integer&gt; path) {&#10;        this.visitPath = path;&#10;        this.currentVisitIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    public void showNextVisitStep() {&#10;        if (currentVisitIndex &lt; visitPath.size() - 1) {&#10;            currentVisitIndex++;&#10;            repaint();&#10;        }&#10;    }&#10;&#10;    public void clearVisitPath() {&#10;        this.visitPath.clear();&#10;        this.currentVisitIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    public boolean hasMoreSteps() {&#10;        return currentVisitIndex &lt; visitPath.size() - 1;&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        if (treeArray == null || treeArray.length &lt;= 1) return;&#10;&#10;        Graphics2D g2d = (Graphics2D) g.create();&#10;        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;&#10;        // 計算樹的最大層數&#10;        int maxLevel = (int) (Math.log(treeArray.length - 1) / Math.log(2)) + 1;&#10;&#10;        // 先畫連接線，再畫節點（避免線條覆蓋節點）&#10;        drawConnections(g2d, maxLevel);&#10;        drawNodes(g2d, maxLevel);&#10;&#10;        g2d.dispose();&#10;    }&#10;&#10;    private void drawConnections(Graphics2D g2d, int maxLevel) {&#10;        g2d.setColor(Color.BLACK);&#10;        g2d.setStroke(new BasicStroke(2));&#10;&#10;        for (int i = 1; i &lt; treeArray.length; i++) {&#10;            if (treeArray[i] == null) continue;&#10;&#10;            int leftChild = 2 * i;&#10;            int rightChild = 2 * i + 1;&#10;&#10;            Point parentPos = getNodePosition(i, maxLevel);&#10;&#10;            // 畫左子節點連線&#10;            if (leftChild &lt; treeArray.length &amp;&amp; treeArray[leftChild] != null) {&#10;                Point leftPos = getNodePosition(leftChild, maxLevel);&#10;                g2d.draw(new Line2D.Double(parentPos.x, parentPos.y, leftPos.x, leftPos.y));&#10;            }&#10;&#10;            // 畫右子節點連線&#10;            if (rightChild &lt; treeArray.length &amp;&amp; treeArray[rightChild] != null) {&#10;                Point rightPos = getNodePosition(rightChild, maxLevel);&#10;                g2d.draw(new Line2D.Double(parentPos.x, parentPos.y, rightPos.x, rightPos.y));&#10;            }&#10;        }&#10;    }&#10;&#10;    private void drawNodes(Graphics2D g2d, int maxLevel) {&#10;        for (int i = 1; i &lt; treeArray.length; i++) {&#10;            if (treeArray[i] == null) continue;&#10;&#10;            Point pos = getNodePosition(i, maxLevel);&#10;            boolean isRoot = (i == 1);&#10;            boolean isLeaf = isLeafNode(i);&#10;            boolean isCurrentVisit = currentVisitIndex &gt;= 0 &amp;&amp; currentVisitIndex &lt; visitPath.size()&#10;                                   &amp;&amp; visitPath.get(currentVisitIndex).equals(treeArray[i]);&#10;            boolean isVisited = isNodeVisited(treeArray[i]);&#10;&#10;            // 設定節點顏色&#10;            if (isCurrentVisit) {&#10;                g2d.setColor(new Color(255, 215, 0));  // 當前走訪節點：金黃色&#10;            } else if (isVisited) {&#10;                g2d.setColor(new Color(144, 238, 144));  // 已走訪節點：淡綠色&#10;            } else if (isRoot) {&#10;                g2d.setColor(Color.BLACK);  // 根節點黑色背景&#10;            } else if (isLeaf) {&#10;                g2d.setColor(Color.WHITE);  // 葉節點白色背景&#10;            } else {&#10;                g2d.setColor(new Color(200, 200, 200));  // 中間節點灰色背景&#10;            }&#10;&#10;            // 畫節點圓圈&#10;            Ellipse2D circle = new Ellipse2D.Double(&#10;                pos.x - NODE_RADIUS, pos.y - NODE_RADIUS,&#10;                2 * NODE_RADIUS, 2 * NODE_RADIUS&#10;            );&#10;            g2d.fill(circle);&#10;&#10;            // 畫節點邊框&#10;            if (isCurrentVisit) {&#10;                g2d.setColor(new Color(255, 140, 0));  // 當前節點橙色邊框&#10;                g2d.setStroke(new BasicStroke(4));&#10;            } else {&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;            }&#10;            g2d.draw(circle);&#10;&#10;            // 設定文字顏色&#10;            if (isRoot &amp;&amp; !isCurrentVisit &amp;&amp; !isVisited) {&#10;                g2d.setColor(Color.WHITE);  // 根節點白色文字&#10;            } else {&#10;                g2d.setColor(Color.BLACK);  // 其他節點黑色文字&#10;            }&#10;&#10;            // 畫節點值&#10;            String text = treeArray[i].toString();&#10;            FontMetrics fm = g2d.getFontMetrics();&#10;            int textWidth = fm.stringWidth(text);&#10;            int textHeight = fm.getAscent();&#10;            g2d.drawString(text,&#10;                pos.x - textWidth / 2,&#10;                pos.y + textHeight / 2 - 2);&#10;&#10;            // 畫陣列編號標示&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;            g2d.setColor(new Color(100, 100, 100));  // 灰色文字&#10;            String indexText = &quot;[&quot; + i + &quot;]&quot;;&#10;            FontMetrics indexFm = g2d.getFontMetrics();&#10;            int indexWidth = indexFm.stringWidth(indexText);&#10;            // 將編號放在節點右上角&#10;            g2d.drawString(indexText,&#10;                pos.x + NODE_RADIUS - indexWidth + 8,&#10;                pos.y - NODE_RADIUS + 12);&#10;            &#10;            // 恢復原本字體&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        }&#10;    }&#10;&#10;    private boolean isNodeVisited(Integer value) {&#10;        for (int i = 0; i &lt;= currentVisitIndex &amp;&amp; i &lt; visitPath.size(); i++) {&#10;            if (visitPath.get(i).equals(value)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private Point getNodePosition(int index, int maxLevel) {&#10;        int level = (int) (Math.log(index) / Math.log(2));&#10;        int nodesInLevel = 1 &lt;&lt; level;&#10;        int positionInLevel = index - (1 &lt;&lt; level);&#10;&#10;        int panelWidth = getWidth();&#10;        int panelHeight = getHeight();&#10;&#10;        // 計算水平位置&#10;        int totalWidth = panelWidth - 2 * NODE_RADIUS;&#10;        int spacing = Math.max(MIN_HORIZONTAL_SPACING, totalWidth / (nodesInLevel + 1));&#10;        int x = NODE_RADIUS + spacing * (positionInLevel + 1);&#10;&#10;        // 確保節點在面板範圍內&#10;        if (nodesInLevel &gt; 1) {&#10;            x = NODE_RADIUS + (totalWidth * (positionInLevel + 1)) / (nodesInLevel + 1);&#10;        } else {&#10;            x = panelWidth / 2;&#10;        }&#10;&#10;        // 計算垂直位置&#10;        int y = NODE_RADIUS + 30 + level * LEVEL_HEIGHT;&#10;&#10;        return new Point(x, y);&#10;    }&#10;&#10;    private boolean isLeafNode(int index) {&#10;        int leftChild = 2 * index;&#10;        int rightChild = 2 * index + 1;&#10;&#10;        boolean hasLeftChild = leftChild &lt; treeArray.length &amp;&amp; treeArray[leftChild] != null;&#10;        boolean hasRightChild = rightChild &lt; treeArray.length &amp;&amp; treeArray[rightChild] != null;&#10;&#10;        return !hasLeftChild &amp;&amp; !hasRightChild;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>