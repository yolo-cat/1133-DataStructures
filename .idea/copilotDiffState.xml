<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/0729-HeapApplication/src/Main.java" />
              <option name="updatedContent" value="public class Main {&#10;    public static void main(String[] args) {&#10;        ProducerConsumerGUI.main(args);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/src/BinaryTreeArray.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/src/BinaryTreeArray.java" />
              <option name="originalContent" value="import java.util.*;&#10;import java.util.stream.IntStream;&#10;&#10;public class BinaryTreeArray {&#10;    private Integer[] treeArray;&#10;&#10;    public BinaryTreeArray(Integer[] arr) {&#10;        this.treeArray = arr;&#10;    }&#10;&#10;    // 工具方法：取得有效索引範圍（1 ~ arr.length-1）&#10;    private int getLeft(int index) { return 2 * index; }&#10;    private int getRight(int index) { return 2 * index + 1; }&#10;    private boolean isValidIndex(int index) { return index &gt; 0 &amp;&amp; index &lt; treeArray.length; }&#10;&#10;    // 前序走訪&#10;    public List&lt;Integer&gt; preorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        preorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void preorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        result.add(treeArray[index]);&#10;        preorderHelper(getLeft(index), result);&#10;        preorderHelper(getRight(index), result);&#10;    }&#10;&#10;    // 中序走訪&#10;    public List&lt;Integer&gt; inorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        inorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void inorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        inorderHelper(getLeft(index), result);&#10;        result.add(treeArray[index]);&#10;        inorderHelper(getRight(index), result);&#10;    }&#10;&#10;    // 後序走訪&#10;    public List&lt;Integer&gt; postorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        postorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void postorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        postorderHelper(getLeft(index), result);&#10;        postorderHelper(getRight(index), result);&#10;        result.add(treeArray[index]);&#10;    }&#10;&#10;    // 靜態方法：將字串陣列轉為 Integer 陣列（支援 null）&#10;    public static Integer[] parseInput(String input) {&#10;        String[] parts = input.split(&quot;,&quot;);&#10;        Integer[] arr = new Integer[parts.length + 1]; // arr[0] 保留&#10;        arr[0] = 0; // 節點數量初始化為0&#10;        for (int i = 0; i &lt; parts.length; i++) {&#10;            String s = parts[i].trim();&#10;            if (s.equalsIgnoreCase(&quot;null&quot;)) arr[i + 1] = null;&#10;            else arr[i + 1] = Integer.parseInt(s);&#10;            if (!s.equalsIgnoreCase(&quot;null&quot;)) arr[0]++;&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // 刪除指定索引的節點&#10;    // 若為樹葉節點則直接刪除，若為中間節點則刪除整個子樹&#10;    public void delete(int index) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        int left = getLeft(index);&#10;        int right = getRight(index);&#10;        boolean isLeaf = (!isValidIndex(left) || treeArray[left] == null)&#10;                &amp;&amp; (!isValidIndex(right) || treeArray[right] == null);&#10;        if (isLeaf) {&#10;            treeArray[index] = null;&#10;        } else {&#10;            deleteSubtree(index);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除以 index 為根的子樹&#10;    private void deleteSubtree(int index) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        treeArray[index] = null;&#10;        deleteSubtree(getLeft(index));&#10;        deleteSubtree(getRight(index));&#10;    }&#10;&#10;    // 測試主程式&#10;    public static void main(String[] args) {&#10;        Scanner sc = new Scanner(System.in);&#10;        System.out.println(&quot;請輸入以逗號分隔的陣列（用null表示空節點）：&quot;);&#10;        String input = sc.nextLine();&#10;        Integer[] arr = parseInput(input);&#10;        BinaryTreeArray tree = new BinaryTreeArray(arr);&#10;        System.out.println(&quot;索引:   &quot; + Arrays.toString(IntStream.range(1, arr.length).toArray()));&#10;        System.out.println(&quot;內容:   &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        System.out.println(&quot;節點數: &quot; + arr[0]);&#10;        System.out.println(&quot;中序: &quot; + tree.inorder());&#10;        System.out.println(&quot;前序: &quot; + tree.preorder());&#10;        System.out.println(&quot;後序: &quot; + tree.postorder());&#10;&#10;        while (true) {&#10;            System.out.println(&quot;請選擇操作: 1) 增加節點 2) 刪除節點 3) 退出&quot;);&#10;            String op = sc.nextLine();&#10;            if (op.equals(&quot;1&quot;)) {&#10;                System.out.print(&quot;請輸入要插入的索引: &quot;);&#10;                int idx = Integer.parseInt(sc.nextLine());&#10;                System.out.print(&quot;請輸入要插入的值(整數): &quot;);&#10;                String valStr = sc.nextLine();&#10;                Integer val = valStr.equalsIgnoreCase(&quot;null&quot;) ? null : Integer.parseInt(valStr);&#10;                if (idx &gt; 0 &amp;&amp; idx &lt; arr.length) {&#10;                    // 若原本為null且新值非null，節點數+1&#10;                    if (arr[idx] == null &amp;&amp; val != null) arr[0]++;&#10;                    // 若原本非null且新值為null，節點數-1&#10;                    if (arr[idx] != null &amp;&amp; val == null) arr[0]--;&#10;                    arr[idx] = val;&#10;                    System.out.println(&quot;已插入於索引 &quot; + idx);&#10;                } else {&#10;                    System.out.println(&quot;索引超出範圍&quot;);&#10;                }&#10;            } else if (op.equals(&quot;2&quot;)) {&#10;                System.out.print(&quot;請輸入要刪除的索引: &quot;);&#10;                int idx = Integer.parseInt(sc.nextLine());&#10;                // 遞迴計算刪除節點數&#10;                int[] delCount = new int[]{0};&#10;                countDelete(arr, idx, delCount);&#10;                tree.delete(idx);&#10;                arr[0] -= delCount[0];&#10;                System.out.println(&quot;已刪除索引 &quot; + idx);&#10;            } else if (op.equals(&quot;3&quot;)) {&#10;                System.out.println(&quot;程式結束&quot;);&#10;                break;&#10;            } else {&#10;                System.out.println(&quot;無效選項&quot;);&#10;            }&#10;            System.out.println(&quot;索引:   &quot; + Arrays.toString(IntStream.range(1, arr.length).toArray()));&#10;            System.out.println(&quot;內容:   &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;            System.out.println(&quot;節點數: &quot; + arr[0]);&#10;            System.out.println(&quot;中序: &quot; + tree.inorder());&#10;            System.out.println(&quot;前序: &quot; + tree.preorder());&#10;            System.out.println(&quot;後序: &quot; + tree.postorder());&#10;        }&#10;    }&#10;&#10;    // 遞迴計算將被刪除的節點數&#10;    private static void countDelete(Integer[] arr, int idx, int[] count) {&#10;        if (idx &lt;= 0 || idx &gt;= arr.length || arr[idx] == null) return;&#10;        count[0]++;&#10;        countDelete(arr, 2 * idx, count);&#10;        countDelete(arr, 2 * idx + 1, count);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.util.*;&#10;import java.util.stream.IntStream;&#10;&#10;public class BinaryTreeArray {&#10;    private Integer[] treeArray;&#10;&#10;    public BinaryTreeArray(Integer[] arr) {&#10;        this.treeArray = arr;&#10;    }&#10;&#10;    // 工具方法：取得有效索引範圍（1 ~ arr.length-1）&#10;    private int getLeft(int index) { return 2 * index; }&#10;    private int getRight(int index) { return 2 * index + 1; }&#10;    private boolean isValidIndex(int index) { return index &gt; 0 &amp;&amp; index &lt; treeArray.length; }&#10;&#10;    // 前序走訪&#10;    public List&lt;Integer&gt; preorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        preorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void preorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        result.add(treeArray[index]);&#10;        preorderHelper(getLeft(index), result);&#10;        preorderHelper(getRight(index), result);&#10;    }&#10;&#10;    // 中序走訪&#10;    public List&lt;Integer&gt; inorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        inorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void inorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        inorderHelper(getLeft(index), result);&#10;        result.add(treeArray[index]);&#10;        inorderHelper(getRight(index), result);&#10;    }&#10;&#10;    // 後序走訪&#10;    public List&lt;Integer&gt; postorder() {&#10;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();&#10;        postorderHelper(1, result);&#10;        return result;&#10;    }&#10;&#10;    private void postorderHelper(int index, List&lt;Integer&gt; result) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        postorderHelper(getLeft(index), result);&#10;        postorderHelper(getRight(index), result);&#10;        result.add(treeArray[index]);&#10;    }&#10;&#10;    // 靜態方法：將字串陣列轉為 Integer 陣列（支援 null）&#10;    public static Integer[] parseInput(String input) {&#10;        String[] parts = input.split(&quot;,&quot;);&#10;        Integer[] arr = new Integer[parts.length + 1]; // arr[0] 保留&#10;        arr[0] = 0; // 節點數量初始化為0&#10;        for (int i = 0; i &lt; parts.length; i++) {&#10;            String s = parts[i].trim();&#10;            if (s.equalsIgnoreCase(&quot;null&quot;)) arr[i + 1] = null;&#10;            else arr[i + 1] = Integer.parseInt(s);&#10;            if (!s.equalsIgnoreCase(&quot;null&quot;)) arr[0]++;&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // 刪除指定索引的節點&#10;    // 若為樹葉節點則直接刪除，若為中間節點則刪除整個子樹&#10;    public void delete(int index) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        int left = getLeft(index);&#10;        int right = getRight(index);&#10;        boolean isLeaf = (!isValidIndex(left) || treeArray[left] == null)&#10;                &amp;&amp; (!isValidIndex(right) || treeArray[right] == null);&#10;        if (isLeaf) {&#10;            treeArray[index] = null;&#10;        } else {&#10;            deleteSubtree(index);&#10;        }&#10;    }&#10;&#10;    // 遞迴刪除以 index 為根的子樹&#10;    private void deleteSubtree(int index) {&#10;        if (!isValidIndex(index) || treeArray[index] == null) return;&#10;        treeArray[index] = null;&#10;        deleteSubtree(getLeft(index));&#10;        deleteSubtree(getRight(index));&#10;    }&#10;&#10;    // 測試主程式&#10;    public static void main(String[] args) {&#10;        Scanner sc = new Scanner(System.in);&#10;        System.out.println(&quot;請輸入以逗號分隔的陣列（用null表示空節點）：&quot;);&#10;        System.out.println(&quot;或輸入 auto:N 由程式自動產生 N 個不重覆隨機數字&quot;);&#10;        String input = sc.nextLine();&#10;        Integer[] arr;&#10;        if (input.trim().toLowerCase().startsWith(&quot;auto:&quot;)) {&#10;            int n = 0;&#10;            try {&#10;                n = Integer.parseInt(input.trim().substring(5));&#10;            } catch (Exception e) {&#10;                System.out.println(&quot;格式錯誤，請輸入 auto:N，例如 auto:10&quot;);&#10;                return;&#10;            }&#10;            if (n &lt;= 0) {&#10;                System.out.println(&quot;N 必須大於 0&quot;);&#10;                return;&#10;            }&#10;            Set&lt;Integer&gt; nums = new LinkedHashSet&lt;&gt;();&#10;            Random rand = new Random();&#10;            while (nums.size() &lt; n) {&#10;                nums.add(rand.nextInt(10000)); // 可調整範圍&#10;            }&#10;            arr = new Integer[n + 1];&#10;            arr[0] = n;&#10;            int i = 1;&#10;            for (int num : nums) arr[i++] = num;&#10;        } else {&#10;            arr = parseInput(input);&#10;        }&#10;        BinaryTreeArray tree = new BinaryTreeArray(arr);&#10;        System.out.println(&quot;索引:   &quot; + Arrays.toString(IntStream.range(1, arr.length).toArray()));&#10;        System.out.println(&quot;內容:   &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        System.out.println(&quot;節點數: &quot; + arr[0]);&#10;        System.out.println(&quot;中序: &quot; + tree.inorder());&#10;        System.out.println(&quot;前序: &quot; + tree.preorder());&#10;        System.out.println(&quot;後序: &quot; + tree.postorder());&#10;&#10;        while (true) {&#10;            System.out.println(&quot;請選擇操作: 1) 增加節點 2) 刪除節點 3) 退出&quot;);&#10;            String op = sc.nextLine();&#10;            if (op.equals(&quot;1&quot;)) {&#10;                System.out.print(&quot;請輸入要插入的索引: &quot;);&#10;                int idx = Integer.parseInt(sc.nextLine());&#10;                System.out.print(&quot;請輸入要插入的值(整數): &quot;);&#10;                String valStr = sc.nextLine();&#10;                Integer val = valStr.equalsIgnoreCase(&quot;null&quot;) ? null : Integer.parseInt(valStr);&#10;                if (idx &gt; 0 &amp;&amp; idx &lt; arr.length) {&#10;                    // 若原本為null且新值非null，節點數+1&#10;                    if (arr[idx] == null &amp;&amp; val != null) arr[0]++;&#10;                    // 若原本非null且新值為null，節點數-1&#10;                    if (arr[idx] != null &amp;&amp; val == null) arr[0]--;&#10;                    arr[idx] = val;&#10;                    System.out.println(&quot;已插入於索引 &quot; + idx);&#10;                } else {&#10;                    System.out.println(&quot;索引超出範圍&quot;);&#10;                }&#10;            } else if (op.equals(&quot;2&quot;)) {&#10;                System.out.print(&quot;請輸入要刪除的索引: &quot;);&#10;                int idx = Integer.parseInt(sc.nextLine());&#10;                // 遞迴計算刪除節點數&#10;                int[] delCount = new int[]{0};&#10;                countDelete(arr, idx, delCount);&#10;                tree.delete(idx);&#10;                arr[0] -= delCount[0];&#10;                System.out.println(&quot;已刪除索引 &quot; + idx);&#10;            } else if (op.equals(&quot;3&quot;)) {&#10;                System.out.println(&quot;程式結束&quot;);&#10;                break;&#10;            } else {&#10;                System.out.println(&quot;無效選項&quot;);&#10;            }&#10;            System.out.println(&quot;索引:   &quot; + Arrays.toString(IntStream.range(1, arr.length).toArray()));&#10;            System.out.println(&quot;內容:   &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;            System.out.println(&quot;節點數: &quot; + arr[0]);&#10;            System.out.println(&quot;中序: &quot; + tree.inorder());&#10;            System.out.println(&quot;前序: &quot; + tree.preorder());&#10;            System.out.println(&quot;後序: &quot; + tree.postorder());&#10;        }&#10;    }&#10;&#10;    // 遞迴計算將被刪除的節點數&#10;    private static void countDelete(Integer[] arr, int idx, int[] count) {&#10;        if (idx &lt;= 0 || idx &gt;= arr.length || arr[idx] == null) return;&#10;        count[0]++;&#10;        countDelete(arr, 2 * idx, count);&#10;        countDelete(arr, 2 * idx + 1, count);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/src/BinaryTreeArrayGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/src/BinaryTreeArrayGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;import java.util.*;&#10;import java.util.stream.IntStream;&#10;&#10;public class BinaryTreeArrayGUI extends JFrame {&#10;    private BinaryTreeArray tree;&#10;    private Integer[] arr;&#10;    private JTextField inputField;&#10;    private JTextField insertIdxField, insertValField;&#10;    private JTextField deleteIdxField;&#10;    private JTextArea outputArea;&#10;    private JLabel nodeCountLabel;&#10;    private TreeVisualizationPanel treePanel;&#10;    private JRadioButton inorderBtn, preorderBtn, postorderBtn;&#10;    private JButton visitBtn;&#10;    private JButton stepBtn, resetBtn;&#10;    private javax.swing.Timer walkTimer;&#10;    private java.util.List&lt;Integer&gt; currentTraversalPath;&#10;&#10;    public BinaryTreeArrayGUI() {&#10;        setTitle(&quot;Binary Tree/Heap 教學系統&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(1000, 800);&#10;        setLayout(new BorderLayout(10, 10));&#10;&#10;        // 設定主要背景色&#10;        getContentPane().setBackground(new Color(248, 249, 250));&#10;&#10;        // 頂部輸入面板&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        topPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;建立二元樹&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        topPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 5, 5, 5);&#10;&#10;        inputField = new JTextField(25);&#10;        inputField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        JButton buildBtn = new JButton(&quot;建立/重設樹&quot;);&#10;        buildBtn.setBackground(new Color(144, 238, 144));  // 淡綠色背景&#10;        buildBtn.setForeground(Color.BLACK);  // 黑色文字&#10;        buildBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;&#10;        JButton autoBtn = new JButton(&quot;自動產生隨機數&quot;);&#10;        autoBtn.setBackground(new Color(144, 238, 144));  // 淡綠色背景&#10;        autoBtn.setForeground(Color.BLACK);  // 黑色文字&#10;        autoBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        JTextField autoNField = new JTextField(5);&#10;        autoNField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;&#10;        gbc.gridx = 0; gbc.gridy = 0;&#10;        topPanel.add(new JLabel(&quot;輸入陣列(逗號分隔, null為空):&quot;), gbc);&#10;        gbc.gridx = 1;&#10;        topPanel.add(inputField, gbc);&#10;        gbc.gridx = 2;&#10;        topPanel.add(buildBtn, gbc);&#10;&#10;        gbc.gridx = 0; gbc.gridy = 1;&#10;        topPanel.add(new JLabel(&quot;或產生 N 個隨機數:&quot;), gbc);&#10;        gbc.gridx = 1;&#10;        topPanel.add(autoNField, gbc);&#10;        gbc.gridx = 2;&#10;        topPanel.add(autoBtn, gbc);&#10;&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        // 中央操作面板&#10;        JPanel centerPanel = new JPanel(new BorderLayout());&#10;&#10;        // 左側操作區&#10;        JPanel leftPanel = new JPanel(new GridBagLayout());&#10;        leftPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;節點操作&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        leftPanel.setBackground(Color.WHITE);&#10;        leftPanel.setPreferredSize(new Dimension(300, 0));&#10;&#10;        GridBagConstraints leftGbc = new GridBagConstraints();&#10;        leftGbc.insets = new Insets(10, 10, 5, 10);&#10;        leftGbc.anchor = GridBagConstraints.WEST;&#10;        leftGbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        // 插入/修改節點區域&#10;        JPanel insertPanel = new JPanel(new GridBagLayout());&#10;        insertPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;插入/修改節點&quot;));&#10;        insertPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints insertGbc = new GridBagConstraints();&#10;        insertGbc.insets = new Insets(5, 5, 5, 5);&#10;        insertGbc.anchor = GridBagConstraints.WEST;&#10;&#10;        insertIdxField = new JTextField(12);&#10;        insertValField = new JTextField(12);&#10;        insertIdxField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        insertValField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        insertIdxField.setHorizontalAlignment(JTextField.LEFT);&#10;        insertValField.setHorizontalAlignment(JTextField.LEFT);&#10;&#10;        JButton insertBtn = new JButton(&quot;插入/修改&quot;);&#10;        insertBtn.setBackground(new Color(144, 238, 144));&#10;        insertBtn.setForeground(Color.BLACK);&#10;        insertBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        insertBtn.setPreferredSize(new Dimension(120, 30));&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 0;&#10;        insertPanel.add(new JLabel(&quot;索引:&quot;), insertGbc);&#10;        insertGbc.gridx = 1;&#10;        insertPanel.add(insertIdxField, insertGbc);&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 1;&#10;        insertPanel.add(new JLabel(&quot;值:&quot;), insertGbc);&#10;        insertGbc.gridx = 1;&#10;        insertPanel.add(insertValField, insertGbc);&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 2; insertGbc.gridwidth = 2;&#10;        insertGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        insertPanel.add(insertBtn, insertGbc);&#10;&#10;        // 刪除節點區域&#10;        JPanel deletePanel = new JPanel(new GridBagLayout());&#10;        deletePanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;刪除節點&quot;));&#10;        deletePanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints deleteGbc = new GridBagConstraints();&#10;        deleteGbc.insets = new Insets(5, 5, 5, 5);&#10;        deleteGbc.anchor = GridBagConstraints.WEST;&#10;&#10;        deleteIdxField = new JTextField(12);&#10;        deleteIdxField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        deleteIdxField.setHorizontalAlignment(JTextField.LEFT);&#10;&#10;        JButton deleteBtn = new JButton(&quot;刪除節點&quot;);&#10;        deleteBtn.setBackground(new Color(144, 238, 144));&#10;        deleteBtn.setForeground(Color.BLACK);&#10;        deleteBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        deleteBtn.setPreferredSize(new Dimension(120, 30));&#10;&#10;        deleteGbc.gridx = 0; deleteGbc.gridy = 0;&#10;        deletePanel.add(new JLabel(&quot;索引:&quot;), deleteGbc);&#10;        deleteGbc.gridx = 1;&#10;        deletePanel.add(deleteIdxField, deleteGbc);&#10;&#10;        deleteGbc.gridx = 0; deleteGbc.gridy = 1; deleteGbc.gridwidth = 2;&#10;        deleteGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        deletePanel.add(deleteBtn, deleteGbc);&#10;&#10;        // 走訪選項區域&#10;        JPanel visitPanel = new JPanel(new GridBagLayout());&#10;        visitPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;樹走訪&quot;));&#10;        visitPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints visitGbc = new GridBagConstraints();&#10;        visitGbc.insets = new Insets(5, 5, 5, 5);&#10;        visitGbc.anchor = GridBagConstraints.WEST;&#10;        visitGbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        inorderBtn = new JRadioButton(&quot;中序 (Inorder)&quot;);&#10;        preorderBtn = new JRadioButton(&quot;前序 (Preorder)&quot;);&#10;        postorderBtn = new JRadioButton(&quot;後序 (Postorder)&quot;);&#10;&#10;        inorderBtn.setBackground(Color.WHITE);&#10;        preorderBtn.setBackground(Color.WHITE);&#10;        postorderBtn.setBackground(Color.WHITE);&#10;&#10;        visitBtn = new JButton(&quot;執行走訪&quot;);&#10;        visitBtn.setBackground(new Color(144, 238, 144));&#10;        visitBtn.setForeground(Color.BLACK);&#10;        visitBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;&#10;        stepBtn = new JButton(&quot;逐步顯示&quot;);&#10;        stepBtn.setBackground(new Color(144, 238, 144));&#10;        stepBtn.setForeground(Color.BLACK);&#10;        stepBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;        stepBtn.setEnabled(false);&#10;&#10;        resetBtn = new JButton(&quot;重置&quot;);&#10;        resetBtn.setBackground(new Color(144, 238, 144));&#10;        resetBtn.setForeground(Color.BLACK);&#10;        resetBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;        resetBtn.setEnabled(false);&#10;&#10;        visitGbc.gridx = 0; visitGbc.gridy = 0; visitGbc.gridwidth = 3;&#10;        visitPanel.add(inorderBtn, visitGbc);&#10;        visitGbc.gridy = 1;&#10;        visitPanel.add(preorderBtn, visitGbc);&#10;        visitGbc.gridy = 2;&#10;        visitPanel.add(postorderBtn, visitGbc);&#10;&#10;        // 控制按鈕區域&#10;        JPanel controlPanel = new JPanel(new GridLayout(1, 3, 3, 3));&#10;        controlPanel.setBackground(Color.WHITE);&#10;        controlPanel.add(visitBtn);&#10;        controlPanel.add(stepBtn);&#10;        controlPanel.add(resetBtn);&#10;&#10;        visitGbc.gridy = 3; visitGbc.insets = new Insets(10, 5, 5, 5);&#10;        visitPanel.add(controlPanel, visitGbc);&#10;&#10;        // 將各個面板添加到左側主面板&#10;        leftGbc.gridx = 0; leftGbc.gridy = 0; leftGbc.weightx = 1.0;&#10;        leftPanel.add(insertPanel, leftGbc);&#10;&#10;        leftGbc.gridy = 1; leftGbc.insets = new Insets(5, 10, 5, 10);&#10;        leftPanel.add(deletePanel, leftGbc);&#10;&#10;        leftGbc.gridy = 2; leftGbc.weighty = 1.0;&#10;        leftPanel.add(visitPanel, leftGbc);&#10;&#10;        centerPanel.add(leftPanel, BorderLayout.WEST);&#10;&#10;        // 右側樹狀顯示區&#10;        JPanel rightPanel = new JPanel(new BorderLayout());&#10;        rightPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;樹狀結構視覺化&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        rightPanel.setBackground(Color.WHITE);&#10;&#10;        treePanel = new TreeVisualizationPanel();&#10;        rightPanel.add(treePanel, BorderLayout.CENTER);&#10;&#10;        centerPanel.add(rightPanel, BorderLayout.CENTER);&#10;        add(centerPanel, BorderLayout.CENTER);&#10;&#10;        // 底部資訊面板&#10;        JPanel bottomPanel = new JPanel(new BorderLayout());&#10;&#10;        // 節點數顯示&#10;        JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        infoPanel.setBackground(new Color(248, 249, 250));&#10;        nodeCountLabel = new JLabel(&quot;節點數: 0&quot;);&#10;        nodeCountLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 14));&#10;        nodeCountLabel.setForeground(new Color(0, 123, 255));&#10;        infoPanel.add(nodeCountLabel);&#10;        bottomPanel.add(infoPanel, BorderLayout.NORTH);&#10;&#10;        // 輸出結果區&#10;        JPanel outputPanel = new JPanel(new BorderLayout());&#10;        outputPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;走訪結果&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        outputPanel.setBackground(Color.WHITE);&#10;&#10;        outputArea = new JTextArea(6, 80);&#10;        outputArea.setEditable(false);&#10;        outputArea.setFont(new Font(&quot;Courier New&quot;, Font.PLAIN, 12));&#10;        outputArea.setBackground(new Color(248, 249, 250));&#10;        outputArea.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));&#10;        outputPanel.add(new JScrollPane(outputArea), BorderLayout.CENTER);&#10;&#10;        bottomPanel.add(outputPanel, BorderLayout.CENTER);&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;&#10;        // 事件處理&#10;        buildBtn.addActionListener(e -&gt; buildTreeFromInput());&#10;        autoBtn.addActionListener(e -&gt; buildTreeAuto(autoNField.getText()));&#10;        insertBtn.addActionListener(e -&gt; insertNode());&#10;        deleteBtn.addActionListener(e -&gt; deleteNode());&#10;        visitBtn.addActionListener(e -&gt; visitTree());&#10;        stepBtn.addActionListener(e -&gt; stepTraversal());&#10;        resetBtn.addActionListener(e -&gt; resetTraversal());&#10;&#10;        // 初始化 Timer&#10;        walkTimer = new javax.swing.Timer(800, e -&gt; {&#10;            if (treePanel.hasMoreSteps()) {&#10;                treePanel.showNextVisitStep();&#10;            } else {&#10;                walkTimer.stop();&#10;                stepBtn.setEnabled(false);&#10;            }&#10;        });&#10;&#10;        // 設定視窗居中&#10;        setLocationRelativeTo(null);&#10;    }&#10;&#10;    private void buildTreeFromInput() {&#10;        String input = inputField.getText().trim();&#10;        arr = BinaryTreeArray.parseInput(input);&#10;        tree = new BinaryTreeArray(arr);&#10;        outputArea.setText(&quot;建立樹的陣列參數: &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void buildTreeAuto(String nStr) {&#10;        int n;&#10;        try {&#10;            n = Integer.parseInt(nStr.trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入正整數N&quot;);&#10;            return;&#10;        }&#10;        if (n &lt;= 0) {&#10;            JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;            return;&#10;        }&#10;        Set&lt;Integer&gt; nums = new LinkedHashSet&lt;&gt;();&#10;        Random rand = new Random();&#10;        while (nums.size() &lt; n) nums.add(rand.nextInt(10000));&#10;        arr = new Integer[n + 1];&#10;        arr[0] = n;&#10;        int i = 1;&#10;        for (int num : nums) arr[i++] = num;&#10;        tree = new BinaryTreeArray(arr);&#10;        inputField.setText(&quot;&quot;);&#10;        outputArea.setText(&quot;建立樹的陣列參數: &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void insertNode() {&#10;        if (arr == null) return;&#10;        int idx;&#10;        try {&#10;            idx = Integer.parseInt(insertIdxField.getText().trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入索引&quot;);&#10;            return;&#10;        }&#10;        String valStr = insertValField.getText().trim();&#10;        Integer val = valStr.equalsIgnoreCase(&quot;null&quot;) ? null : null;&#10;        if (!valStr.equalsIgnoreCase(&quot;null&quot;)) {&#10;            try {&#10;                val = Integer.parseInt(valStr);&#10;            } catch (Exception e) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入整數或null&quot;);&#10;                return;&#10;            }&#10;        }&#10;        if (idx &gt; 0 &amp;&amp; idx &lt; arr.length) {&#10;            if (arr[idx] == null &amp;&amp; val != null) arr[0]++;&#10;            if (arr[idx] != null &amp;&amp; val == null) arr[0]--;&#10;            arr[idx] = val;&#10;            tree = new BinaryTreeArray(arr);&#10;            updateDisplay(false);&#10;        } else {&#10;            JOptionPane.showMessageDialog(this, &quot;索引超出範圍&quot;);&#10;        }&#10;    }&#10;&#10;    private void deleteNode() {&#10;        if (arr == null) return;&#10;        int idx;&#10;        try {&#10;            idx = Integer.parseInt(deleteIdxField.getText().trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入索引&quot;);&#10;            return;&#10;        }&#10;        int[] delCount = new int[]{0};&#10;        countDelete(arr, idx, delCount);&#10;        tree.delete(idx);&#10;        arr[0] -= delCount[0];&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void updateDisplay(boolean showTraversal) {&#10;        if (arr == null) return;&#10;        nodeCountLabel.setText(&quot;節點數: &quot; + arr[0]);&#10;&#10;        // 更新樹狀視覺化&#10;        treePanel.setTreeArray(arr);&#10;&#10;        if (tree != null &amp;&amp; showTraversal) {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderBtn.isSelected()) {&#10;                sb.append(&quot;中序: &quot;).append(tree.inorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (preorderBtn.isSelected()) {&#10;                sb.append(&quot;前序: &quot;).append(tree.preorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (postorderBtn.isSelected()) {&#10;                sb.append(&quot;後序: &quot;).append(tree.postorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (sb.length() == 0) {&#10;                sb.append(&quot;請至少選擇一種走訪方式&quot;);&#10;            }&#10;            outputArea.setText(sb.toString());&#10;        }&#10;    }&#10;&#10;    // 遞迴計算將被刪除的節點數&#10;    private static void countDelete(Integer[] arr, int idx, int[] count) {&#10;        if (idx &lt;= 0 || idx &gt;= arr.length || arr[idx] == null) return;&#10;        count[0]++;&#10;        countDelete(arr, 2 * idx, count);&#10;        countDelete(arr, 2 * idx + 1, count);&#10;    }&#10;&#10;    private void visitTree() {&#10;        if (tree == null) return;&#10;&#10;        currentTraversalPath = new ArrayList&lt;&gt;();&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        if (inorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; inorderResult = tree.inorder();&#10;            currentTraversalPath.addAll(inorderResult);&#10;            sb.append(&quot;中序: &quot;).append(inorderResult).append(&quot;\n&quot;);&#10;        }&#10;        if (preorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; preorderResult = tree.preorder();&#10;            if (!inorderBtn.isSelected()) currentTraversalPath.addAll(preorderResult);&#10;            sb.append(&quot;前序: &quot;).append(preorderResult).append(&quot;\n&quot;);&#10;        }&#10;        if (postorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; postorderResult = tree.postorder();&#10;            if (!inorderBtn.isSelected() &amp;&amp; !preorderBtn.isSelected()) currentTraversalPath.addAll(postorderResult);&#10;            sb.append(&quot;後序: &quot;).append(postorderResult).append(&quot;\n&quot;);&#10;        }&#10;&#10;        if (sb.length() == 0) {&#10;            sb.append(&quot;請至少選擇一種走訪方式&quot;);&#10;            outputArea.setText(sb.toString());&#10;            return;&#10;        }&#10;&#10;        // 設定走訪路徑到視覺化面板&#10;        treePanel.setVisitPath(currentTraversalPath);&#10;        outputArea.setText(sb.toString());&#10;&#10;        // 啟用控制按鈕&#10;        stepBtn.setEnabled(true);&#10;        resetBtn.setEnabled(true);&#10;    }&#10;&#10;    private void stepTraversal() {&#10;        if (currentTraversalPath != null &amp;&amp; !currentTraversalPath.isEmpty()) {&#10;            if (treePanel.hasMoreSteps()) {&#10;                treePanel.showNextVisitStep();&#10;                if (!treePanel.hasMoreSteps()) {&#10;                    stepBtn.setEnabled(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void resetTraversal() {&#10;        if (walkTimer.isRunning()) {&#10;            walkTimer.stop();&#10;        }&#10;        treePanel.clearVisitPath();&#10;        stepBtn.setEnabled(currentTraversalPath != null &amp;&amp; !currentTraversalPath.isEmpty());&#10;        resetBtn.setEnabled(false);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            BinaryTreeArrayGUI gui = new BinaryTreeArrayGUI();&#10;            gui.setVisible(true);&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.*;&#10;import java.util.*;&#10;import java.util.stream.IntStream;&#10;&#10;public class BinaryTreeArrayGUI extends JFrame {&#10;    private BinaryTreeArray tree;&#10;    private Integer[] arr;&#10;    private JTextField inputField;&#10;    private JTextField insertIdxField, insertValField;&#10;    private JTextField deleteIdxField;&#10;    private JTextArea outputArea;&#10;    private JLabel nodeCountLabel;&#10;    private TreeVisualizationPanel treePanel;&#10;    private JRadioButton inorderBtn, preorderBtn, postorderBtn;&#10;    private JButton visitBtn;&#10;    private JButton stepBtn, resetBtn;&#10;    private javax.swing.Timer walkTimer;&#10;    private java.util.List&lt;Integer&gt; currentTraversalPath;&#10;&#10;    public BinaryTreeArrayGUI() {&#10;        setTitle(&quot;Binary Tree/Heap 教學系統&quot;);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setSize(1000, 800);&#10;        setLayout(new BorderLayout(10, 10));&#10;&#10;        // 設定主要背景色&#10;        getContentPane().setBackground(new Color(248, 249, 250));&#10;&#10;        // 頂部輸入面板&#10;        JPanel topPanel = new JPanel(new GridBagLayout());&#10;        topPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;建立二元樹&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        topPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 5, 5, 5);&#10;&#10;        inputField = new JTextField(25);&#10;        inputField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        JButton buildBtn = new JButton(&quot;建立/重設樹&quot;);&#10;        buildBtn.setBackground(new Color(144, 238, 144));  // 淡綠色背景&#10;        buildBtn.setForeground(Color.BLACK);  // 黑色文字&#10;        buildBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;&#10;        JButton autoBtn = new JButton(&quot;自動產生隨機數&quot;);&#10;        autoBtn.setBackground(new Color(144, 238, 144));  // 淡綠色背景&#10;        autoBtn.setForeground(Color.BLACK);  // 黑色文字&#10;        autoBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        JTextField autoNField = new JTextField(5);&#10;        autoNField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;&#10;        gbc.gridx = 0; gbc.gridy = 0;&#10;        topPanel.add(new JLabel(&quot;輸入陣列(逗號分隔, null為空):&quot;), gbc);&#10;        gbc.gridx = 1;&#10;        topPanel.add(inputField, gbc);&#10;        gbc.gridx = 2;&#10;        topPanel.add(buildBtn, gbc);&#10;&#10;        gbc.gridx = 0; gbc.gridy = 1;&#10;        topPanel.add(new JLabel(&quot;或產生 N 個隨機數:&quot;), gbc);&#10;        gbc.gridx = 1;&#10;        topPanel.add(autoNField, gbc);&#10;        gbc.gridx = 2;&#10;        topPanel.add(autoBtn, gbc);&#10;&#10;        add(topPanel, BorderLayout.NORTH);&#10;&#10;        // 中央操作面板&#10;        JPanel centerPanel = new JPanel(new BorderLayout());&#10;&#10;        // 左側操作區&#10;        JPanel leftPanel = new JPanel(new GridBagLayout());&#10;        leftPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;節點操作&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        leftPanel.setBackground(Color.WHITE);&#10;        leftPanel.setPreferredSize(new Dimension(300, 0));&#10;&#10;        GridBagConstraints leftGbc = new GridBagConstraints();&#10;        leftGbc.insets = new Insets(10, 10, 5, 10);&#10;        leftGbc.anchor = GridBagConstraints.WEST;&#10;        leftGbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        // 插入/修改節點區域&#10;        JPanel insertPanel = new JPanel(new GridBagLayout());&#10;        insertPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;插入/修改節點&quot;));&#10;        insertPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints insertGbc = new GridBagConstraints();&#10;        insertGbc.insets = new Insets(8, 8, 8, 8);&#10;        insertGbc.anchor = GridBagConstraints.WEST;&#10;&#10;        insertIdxField = new JTextField(15);&#10;        insertValField = new JTextField(15);&#10;        insertIdxField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 14));&#10;        insertValField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 14));&#10;        insertIdxField.setHorizontalAlignment(JTextField.LEFT);&#10;        insertValField.setHorizontalAlignment(JTextField.LEFT);&#10;        &#10;        // 設定較大的首選大小&#10;        insertIdxField.setPreferredSize(new Dimension(150, 28));&#10;        insertValField.setPreferredSize(new Dimension(150, 28));&#10;&#10;        JButton insertBtn = new JButton(&quot;插入/修改&quot;);&#10;        insertBtn.setBackground(new Color(144, 238, 144));&#10;        insertBtn.setForeground(Color.BLACK);&#10;        insertBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        insertBtn.setPreferredSize(new Dimension(140, 32));&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 0;&#10;        insertPanel.add(new JLabel(&quot;索引:&quot;), insertGbc);&#10;        insertGbc.gridx = 1; insertGbc.weightx = 1.0; insertGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        insertPanel.add(insertIdxField, insertGbc);&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 1; insertGbc.weightx = 0.0; insertGbc.fill = GridBagConstraints.NONE;&#10;        insertPanel.add(new JLabel(&quot;值:&quot;), insertGbc);&#10;        insertGbc.gridx = 1; insertGbc.weightx = 1.0; insertGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        insertPanel.add(insertValField, insertGbc);&#10;&#10;        insertGbc.gridx = 0; insertGbc.gridy = 2; insertGbc.gridwidth = 2; insertGbc.weightx = 0.0;&#10;        insertGbc.fill = GridBagConstraints.HORIZONTAL; insertGbc.insets = new Insets(12, 8, 8, 8);&#10;        insertPanel.add(insertBtn, insertGbc);&#10;&#10;        // 刪除節點區域&#10;        JPanel deletePanel = new JPanel(new GridBagLayout());&#10;        deletePanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;刪除節點&quot;));&#10;        deletePanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints deleteGbc = new GridBagConstraints();&#10;        deleteGbc.insets = new Insets(8, 8, 8, 8);&#10;        deleteGbc.anchor = GridBagConstraints.WEST;&#10;&#10;        deleteIdxField = new JTextField(15);&#10;        deleteIdxField.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 14));&#10;        deleteIdxField.setHorizontalAlignment(JTextField.LEFT);&#10;        deleteIdxField.setPreferredSize(new Dimension(150, 28));&#10;&#10;        JButton deleteBtn = new JButton(&quot;刪除節點&quot;);&#10;        deleteBtn.setBackground(new Color(144, 238, 144));&#10;        deleteBtn.setForeground(Color.BLACK);&#10;        deleteBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        deleteBtn.setPreferredSize(new Dimension(140, 32));&#10;&#10;        deleteGbc.gridx = 0; deleteGbc.gridy = 0;&#10;        deletePanel.add(new JLabel(&quot;索引:&quot;), deleteGbc);&#10;        deleteGbc.gridx = 1; deleteGbc.weightx = 1.0; deleteGbc.fill = GridBagConstraints.HORIZONTAL;&#10;        deletePanel.add(deleteIdxField, deleteGbc);&#10;&#10;        deleteGbc.gridx = 0; deleteGbc.gridy = 1; deleteGbc.gridwidth = 2; deleteGbc.weightx = 0.0;&#10;        deleteGbc.fill = GridBagConstraints.HORIZONTAL; deleteGbc.insets = new Insets(12, 8, 8, 8);&#10;        deletePanel.add(deleteBtn, deleteGbc);&#10;&#10;        // 走訪選項區域&#10;        JPanel visitPanel = new JPanel(new GridBagLayout());&#10;        visitPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createLineBorder(new Color(144, 238, 144), 1), &quot;樹走訪&quot;));&#10;        visitPanel.setBackground(Color.WHITE);&#10;&#10;        GridBagConstraints visitGbc = new GridBagConstraints();&#10;        visitGbc.insets = new Insets(5, 5, 5, 5);&#10;        visitGbc.anchor = GridBagConstraints.WEST;&#10;        visitGbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        inorderBtn = new JRadioButton(&quot;中序 (Inorder)&quot;);&#10;        preorderBtn = new JRadioButton(&quot;前序 (Preorder)&quot;);&#10;        postorderBtn = new JRadioButton(&quot;後序 (Postorder)&quot;);&#10;&#10;        inorderBtn.setBackground(Color.WHITE);&#10;        preorderBtn.setBackground(Color.WHITE);&#10;        postorderBtn.setBackground(Color.WHITE);&#10;&#10;        visitBtn = new JButton(&quot;執行走訪&quot;);&#10;        visitBtn.setBackground(new Color(144, 238, 144));&#10;        visitBtn.setForeground(Color.BLACK);&#10;        visitBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;&#10;        stepBtn = new JButton(&quot;逐步顯示&quot;);&#10;        stepBtn.setBackground(new Color(144, 238, 144));&#10;        stepBtn.setForeground(Color.BLACK);&#10;        stepBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;        stepBtn.setEnabled(false);&#10;&#10;        resetBtn = new JButton(&quot;重置&quot;);&#10;        resetBtn.setBackground(new Color(144, 238, 144));&#10;        resetBtn.setForeground(Color.BLACK);&#10;        resetBtn.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 11));&#10;        resetBtn.setEnabled(false);&#10;&#10;        visitGbc.gridx = 0; visitGbc.gridy = 0; visitGbc.gridwidth = 3;&#10;        visitPanel.add(inorderBtn, visitGbc);&#10;        visitGbc.gridy = 1;&#10;        visitPanel.add(preorderBtn, visitGbc);&#10;        visitGbc.gridy = 2;&#10;        visitPanel.add(postorderBtn, visitGbc);&#10;&#10;        // 控制按鈕區域&#10;        JPanel controlPanel = new JPanel(new GridLayout(1, 3, 3, 3));&#10;        controlPanel.setBackground(Color.WHITE);&#10;        controlPanel.add(visitBtn);&#10;        controlPanel.add(stepBtn);&#10;        controlPanel.add(resetBtn);&#10;&#10;        visitGbc.gridy = 3; visitGbc.insets = new Insets(10, 5, 5, 5);&#10;        visitPanel.add(controlPanel, visitGbc);&#10;&#10;        // 將各個面板添加到左側主面板&#10;        leftGbc.gridx = 0; leftGbc.gridy = 0; leftGbc.weightx = 1.0;&#10;        leftPanel.add(insertPanel, leftGbc);&#10;&#10;        leftGbc.gridy = 1; leftGbc.insets = new Insets(5, 10, 5, 10);&#10;        leftPanel.add(deletePanel, leftGbc);&#10;&#10;        leftGbc.gridy = 2; leftGbc.weighty = 1.0;&#10;        leftPanel.add(visitPanel, leftGbc);&#10;&#10;        centerPanel.add(leftPanel, BorderLayout.WEST);&#10;&#10;        // 右側樹狀顯示區&#10;        JPanel rightPanel = new JPanel(new BorderLayout());&#10;        rightPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;樹狀結構視覺化&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        rightPanel.setBackground(Color.WHITE);&#10;&#10;        treePanel = new TreeVisualizationPanel();&#10;        rightPanel.add(treePanel, BorderLayout.CENTER);&#10;&#10;        centerPanel.add(rightPanel, BorderLayout.CENTER);&#10;        add(centerPanel, BorderLayout.CENTER);&#10;&#10;        // 底部資訊面板&#10;        JPanel bottomPanel = new JPanel(new BorderLayout());&#10;&#10;        // 節點數顯示&#10;        JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        infoPanel.setBackground(new Color(248, 249, 250));&#10;        nodeCountLabel = new JLabel(&quot;節點數: 0&quot;);&#10;        nodeCountLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 14));&#10;        nodeCountLabel.setForeground(new Color(0, 123, 255));&#10;        infoPanel.add(nodeCountLabel);&#10;        bottomPanel.add(infoPanel, BorderLayout.NORTH);&#10;&#10;        // 輸出結果區&#10;        JPanel outputPanel = new JPanel(new BorderLayout());&#10;        outputPanel.setBorder(BorderFactory.createTitledBorder(&#10;            BorderFactory.createEtchedBorder(), &quot;走訪結果&quot;,&#10;            0, 0, new Font(&quot;Arial&quot;, Font.BOLD, 14)));&#10;        outputPanel.setBackground(Color.WHITE);&#10;&#10;        outputArea = new JTextArea(6, 80);&#10;        outputArea.setEditable(false);&#10;        outputArea.setFont(new Font(&quot;Courier New&quot;, Font.PLAIN, 12));&#10;        outputArea.setBackground(new Color(248, 249, 250));&#10;        outputArea.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));&#10;        outputPanel.add(new JScrollPane(outputArea), BorderLayout.CENTER);&#10;&#10;        bottomPanel.add(outputPanel, BorderLayout.CENTER);&#10;        add(bottomPanel, BorderLayout.SOUTH);&#10;&#10;        // 事件處理&#10;        buildBtn.addActionListener(e -&gt; buildTreeFromInput());&#10;        autoBtn.addActionListener(e -&gt; buildTreeAuto(autoNField.getText()));&#10;        insertBtn.addActionListener(e -&gt; insertNode());&#10;        deleteBtn.addActionListener(e -&gt; deleteNode());&#10;        visitBtn.addActionListener(e -&gt; visitTree());&#10;        stepBtn.addActionListener(e -&gt; stepTraversal());&#10;        resetBtn.addActionListener(e -&gt; resetTraversal());&#10;&#10;        // 初始化 Timer&#10;        walkTimer = new javax.swing.Timer(800, e -&gt; {&#10;            if (treePanel.hasMoreSteps()) {&#10;                treePanel.showNextVisitStep();&#10;            } else {&#10;                walkTimer.stop();&#10;                stepBtn.setEnabled(false);&#10;            }&#10;        });&#10;&#10;        // 設定視窗居中&#10;        setLocationRelativeTo(null);&#10;    }&#10;&#10;    private void buildTreeFromInput() {&#10;        String input = inputField.getText().trim();&#10;        arr = BinaryTreeArray.parseInput(input);&#10;        tree = new BinaryTreeArray(arr);&#10;        outputArea.setText(&quot;建立樹的陣列參數: &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void buildTreeAuto(String nStr) {&#10;        int n;&#10;        try {&#10;            n = Integer.parseInt(nStr.trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入正整數N&quot;);&#10;            return;&#10;        }&#10;        if (n &lt;= 0) {&#10;            JOptionPane.showMessageDialog(this, &quot;N必須大於0&quot;);&#10;            return;&#10;        }&#10;        Set&lt;Integer&gt; nums = new LinkedHashSet&lt;&gt;();&#10;        Random rand = new Random();&#10;        while (nums.size() &lt; n) nums.add(rand.nextInt(10000));&#10;        arr = new Integer[n + 1];&#10;        arr[0] = n;&#10;        int i = 1;&#10;        for (int num : nums) arr[i++] = num;&#10;        tree = new BinaryTreeArray(arr);&#10;        inputField.setText(&quot;&quot;);&#10;        outputArea.setText(&quot;建立樹的陣列參數: &quot; + Arrays.toString(Arrays.copyOfRange(arr, 1, arr.length)));&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void insertNode() {&#10;        if (arr == null) return;&#10;        int idx;&#10;        try {&#10;            idx = Integer.parseInt(insertIdxField.getText().trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入索引&quot;);&#10;            return;&#10;        }&#10;        String valStr = insertValField.getText().trim();&#10;        Integer val = valStr.equalsIgnoreCase(&quot;null&quot;) ? null : null;&#10;        if (!valStr.equalsIgnoreCase(&quot;null&quot;)) {&#10;            try {&#10;                val = Integer.parseInt(valStr);&#10;            } catch (Exception e) {&#10;                JOptionPane.showMessageDialog(this, &quot;請輸入整數或null&quot;);&#10;                return;&#10;            }&#10;        }&#10;        if (idx &gt; 0 &amp;&amp; idx &lt; arr.length) {&#10;            if (arr[idx] == null &amp;&amp; val != null) arr[0]++;&#10;            if (arr[idx] != null &amp;&amp; val == null) arr[0]--;&#10;            arr[idx] = val;&#10;            tree = new BinaryTreeArray(arr);&#10;            updateDisplay(false);&#10;        } else {&#10;            JOptionPane.showMessageDialog(this, &quot;索引超出範圍&quot;);&#10;        }&#10;    }&#10;&#10;    private void deleteNode() {&#10;        if (arr == null) return;&#10;        int idx;&#10;        try {&#10;            idx = Integer.parseInt(deleteIdxField.getText().trim());&#10;        } catch (Exception e) {&#10;            JOptionPane.showMessageDialog(this, &quot;請輸入索引&quot;);&#10;            return;&#10;        }&#10;        int[] delCount = new int[]{0};&#10;        countDelete(arr, idx, delCount);&#10;        tree.delete(idx);&#10;        arr[0] -= delCount[0];&#10;        updateDisplay(false);&#10;    }&#10;&#10;    private void updateDisplay(boolean showTraversal) {&#10;        if (arr == null) return;&#10;        nodeCountLabel.setText(&quot;節點數: &quot; + arr[0]);&#10;&#10;        // 更新樹狀視覺化&#10;        treePanel.setTreeArray(arr);&#10;&#10;        if (tree != null &amp;&amp; showTraversal) {&#10;            StringBuilder sb = new StringBuilder();&#10;            if (inorderBtn.isSelected()) {&#10;                sb.append(&quot;中序: &quot;).append(tree.inorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (preorderBtn.isSelected()) {&#10;                sb.append(&quot;前序: &quot;).append(tree.preorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (postorderBtn.isSelected()) {&#10;                sb.append(&quot;後序: &quot;).append(tree.postorder()).append(&quot;\n&quot;);&#10;            }&#10;            if (sb.length() == 0) {&#10;                sb.append(&quot;請至少選擇一種走訪方式&quot;);&#10;            }&#10;            outputArea.setText(sb.toString());&#10;        }&#10;    }&#10;&#10;    // 遞迴計算將被刪除的節點數&#10;    private static void countDelete(Integer[] arr, int idx, int[] count) {&#10;        if (idx &lt;= 0 || idx &gt;= arr.length || arr[idx] == null) return;&#10;        count[0]++;&#10;        countDelete(arr, 2 * idx, count);&#10;        countDelete(arr, 2 * idx + 1, count);&#10;    }&#10;&#10;    private void visitTree() {&#10;        if (tree == null) return;&#10;&#10;        currentTraversalPath = new ArrayList&lt;&gt;();&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        if (inorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; inorderResult = tree.inorder();&#10;            currentTraversalPath.addAll(inorderResult);&#10;            sb.append(&quot;中序: &quot;).append(inorderResult).append(&quot;\n&quot;);&#10;        }&#10;        if (preorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; preorderResult = tree.preorder();&#10;            if (!inorderBtn.isSelected()) currentTraversalPath.addAll(preorderResult);&#10;            sb.append(&quot;前序: &quot;).append(preorderResult).append(&quot;\n&quot;);&#10;        }&#10;        if (postorderBtn.isSelected()) {&#10;            java.util.List&lt;Integer&gt; postorderResult = tree.postorder();&#10;            if (!inorderBtn.isSelected() &amp;&amp; !preorderBtn.isSelected()) currentTraversalPath.addAll(postorderResult);&#10;            sb.append(&quot;後序: &quot;).append(postorderResult).append(&quot;\n&quot;);&#10;        }&#10;&#10;        if (sb.length() == 0) {&#10;            sb.append(&quot;請至少選擇一種走訪方式&quot;);&#10;            outputArea.setText(sb.toString());&#10;            return;&#10;        }&#10;&#10;        // 設定走訪路徑到視覺化面板&#10;        treePanel.setVisitPath(currentTraversalPath);&#10;        outputArea.setText(sb.toString());&#10;&#10;        // 啟用控制按鈕&#10;        stepBtn.setEnabled(true);&#10;        resetBtn.setEnabled(true);&#10;    }&#10;&#10;    private void stepTraversal() {&#10;        if (currentTraversalPath != null &amp;&amp; !currentTraversalPath.isEmpty()) {&#10;            if (treePanel.hasMoreSteps()) {&#10;                treePanel.showNextVisitStep();&#10;                if (!treePanel.hasMoreSteps()) {&#10;                    stepBtn.setEnabled(false);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void resetTraversal() {&#10;        if (walkTimer.isRunning()) {&#10;            walkTimer.stop();&#10;        }&#10;        treePanel.clearVisitPath();&#10;        stepBtn.setEnabled(currentTraversalPath != null &amp;&amp; !currentTraversalPath.isEmpty());&#10;        resetBtn.setEnabled(false);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            BinaryTreeArrayGUI gui = new BinaryTreeArrayGUI();&#10;            gui.setVisible(true);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0729-Tree/src/TreeVisualizationPanel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0729-Tree/src/TreeVisualizationPanel.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.geom.Ellipse2D;&#10;import java.awt.geom.Line2D;&#10;import java.util.ArrayList;&#10;&#10;public class TreeVisualizationPanel extends JPanel {&#10;    private Integer[] treeArray;&#10;    private java.util.List&lt;Integer&gt; visitPath;&#10;    private int currentVisitIndex;&#10;    private static final int NODE_RADIUS = 20;&#10;    private static final int LEVEL_HEIGHT = 80;&#10;    private static final int MIN_HORIZONTAL_SPACING = 50;&#10;&#10;    public TreeVisualizationPanel() {&#10;        setBackground(new Color(248, 249, 250));&#10;        setPreferredSize(new Dimension(600, 400));&#10;        visitPath = new ArrayList&lt;&gt;();&#10;        currentVisitIndex = -1;&#10;    }&#10;&#10;    public void setTreeArray(Integer[] arr) {&#10;        this.treeArray = arr;&#10;        clearVisitPath();&#10;        repaint();&#10;    }&#10;&#10;    public void setVisitPath(java.util.List&lt;Integer&gt; path) {&#10;        this.visitPath = path;&#10;        this.currentVisitIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    public void showNextVisitStep() {&#10;        if (currentVisitIndex &lt; visitPath.size() - 1) {&#10;            currentVisitIndex++;&#10;            repaint();&#10;        }&#10;    }&#10;&#10;    public void clearVisitPath() {&#10;        this.visitPath.clear();&#10;        this.currentVisitIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    public boolean hasMoreSteps() {&#10;        return currentVisitIndex &lt; visitPath.size() - 1;&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        if (treeArray == null || treeArray.length &lt;= 1) return;&#10;&#10;        Graphics2D g2d = (Graphics2D) g.create();&#10;        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;&#10;        // 計算樹的最大層數&#10;        int maxLevel = (int) (Math.log(treeArray.length - 1) / Math.log(2)) + 1;&#10;&#10;        // 先畫連接線，再畫節點（避免線條覆蓋節點）&#10;        drawConnections(g2d, maxLevel);&#10;        drawNodes(g2d, maxLevel);&#10;&#10;        g2d.dispose();&#10;    }&#10;&#10;    private void drawConnections(Graphics2D g2d, int maxLevel) {&#10;        g2d.setColor(Color.BLACK);&#10;        g2d.setStroke(new BasicStroke(2));&#10;&#10;        for (int i = 1; i &lt; treeArray.length; i++) {&#10;            if (treeArray[i] == null) continue;&#10;&#10;            int leftChild = 2 * i;&#10;            int rightChild = 2 * i + 1;&#10;&#10;            Point parentPos = getNodePosition(i, maxLevel);&#10;&#10;            // 畫左子節點連線&#10;            if (leftChild &lt; treeArray.length &amp;&amp; treeArray[leftChild] != null) {&#10;                Point leftPos = getNodePosition(leftChild, maxLevel);&#10;                g2d.draw(new Line2D.Double(parentPos.x, parentPos.y, leftPos.x, leftPos.y));&#10;            }&#10;&#10;            // 畫右子節點連線&#10;            if (rightChild &lt; treeArray.length &amp;&amp; treeArray[rightChild] != null) {&#10;                Point rightPos = getNodePosition(rightChild, maxLevel);&#10;                g2d.draw(new Line2D.Double(parentPos.x, parentPos.y, rightPos.x, rightPos.y));&#10;            }&#10;        }&#10;    }&#10;&#10;    private void drawNodes(Graphics2D g2d, int maxLevel) {&#10;        for (int i = 1; i &lt; treeArray.length; i++) {&#10;            if (treeArray[i] == null) continue;&#10;&#10;            Point pos = getNodePosition(i, maxLevel);&#10;            boolean isRoot = (i == 1);&#10;            boolean isLeaf = isLeafNode(i);&#10;            boolean isCurrentVisit = currentVisitIndex &gt;= 0 &amp;&amp; currentVisitIndex &lt; visitPath.size()&#10;                                   &amp;&amp; visitPath.get(currentVisitIndex).equals(treeArray[i]);&#10;            boolean isVisited = isNodeVisited(treeArray[i]);&#10;&#10;            // 設定節點顏色&#10;            if (isCurrentVisit) {&#10;                g2d.setColor(new Color(255, 215, 0));  // 當前走訪節點：金黃色&#10;            } else if (isVisited) {&#10;                g2d.setColor(new Color(144, 238, 144));  // 已走訪節點：淡綠色&#10;            } else if (isRoot) {&#10;                g2d.setColor(Color.BLACK);  // 根節點黑色背景&#10;            } else if (isLeaf) {&#10;                g2d.setColor(Color.WHITE);  // 葉節點白色背景&#10;            } else {&#10;                g2d.setColor(new Color(200, 200, 200));  // 中間節點灰色背景&#10;            }&#10;&#10;            // 畫節點圓圈&#10;            Ellipse2D circle = new Ellipse2D.Double(&#10;                pos.x - NODE_RADIUS, pos.y - NODE_RADIUS,&#10;                2 * NODE_RADIUS, 2 * NODE_RADIUS&#10;            );&#10;            g2d.fill(circle);&#10;&#10;            // 畫節點邊框&#10;            if (isCurrentVisit) {&#10;                g2d.setColor(new Color(255, 140, 0));  // 當前節點橙色邊框&#10;                g2d.setStroke(new BasicStroke(4));&#10;            } else {&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;            }&#10;            g2d.draw(circle);&#10;&#10;            // 設定文字顏色&#10;            if (isRoot &amp;&amp; !isCurrentVisit &amp;&amp; !isVisited) {&#10;                g2d.setColor(Color.WHITE);  // 根節點白色文字&#10;            } else {&#10;                g2d.setColor(Color.BLACK);  // 其他節點黑色文字&#10;            }&#10;&#10;            // 畫節點值&#10;            String text = treeArray[i].toString();&#10;            FontMetrics fm = g2d.getFontMetrics();&#10;            int textWidth = fm.stringWidth(text);&#10;            int textHeight = fm.getAscent();&#10;            g2d.drawString(text,&#10;                pos.x - textWidth / 2,&#10;                pos.y + textHeight / 2 - 2);&#10;        }&#10;    }&#10;&#10;    private boolean isNodeVisited(Integer value) {&#10;        for (int i = 0; i &lt;= currentVisitIndex &amp;&amp; i &lt; visitPath.size(); i++) {&#10;            if (visitPath.get(i).equals(value)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private Point getNodePosition(int index, int maxLevel) {&#10;        int level = (int) (Math.log(index) / Math.log(2));&#10;        int nodesInLevel = 1 &lt;&lt; level;&#10;        int positionInLevel = index - (1 &lt;&lt; level);&#10;&#10;        int panelWidth = getWidth();&#10;        int panelHeight = getHeight();&#10;&#10;        // 計算水平位置&#10;        int totalWidth = panelWidth - 2 * NODE_RADIUS;&#10;        int spacing = Math.max(MIN_HORIZONTAL_SPACING, totalWidth / (nodesInLevel + 1));&#10;        int x = NODE_RADIUS + spacing * (positionInLevel + 1);&#10;&#10;        // 確保節點在面板範圍內&#10;        if (nodesInLevel &gt; 1) {&#10;            x = NODE_RADIUS + (totalWidth * (positionInLevel + 1)) / (nodesInLevel + 1);&#10;        } else {&#10;            x = panelWidth / 2;&#10;        }&#10;&#10;        // 計算垂直位置&#10;        int y = NODE_RADIUS + 30 + level * LEVEL_HEIGHT;&#10;&#10;        return new Point(x, y);&#10;    }&#10;&#10;    private boolean isLeafNode(int index) {&#10;        int leftChild = 2 * index;&#10;        int rightChild = 2 * index + 1;&#10;&#10;        boolean hasLeftChild = leftChild &lt; treeArray.length &amp;&amp; treeArray[leftChild] != null;&#10;        boolean hasRightChild = rightChild &lt; treeArray.length &amp;&amp; treeArray[rightChild] != null;&#10;&#10;        return !hasLeftChild &amp;&amp; !hasRightChild;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.geom.Ellipse2D;&#10;import java.awt.geom.Line2D;&#10;import java.util.ArrayList;&#10;&#10;public class TreeVisualizationPanel extends JPanel {&#10;    private Integer[] treeArray;&#10;    private java.util.List&lt;Integer&gt; visitPath;&#10;    private int currentVisitIndex;&#10;    private static final int NODE_RADIUS = 20;&#10;    private static final int LEVEL_HEIGHT = 80;&#10;    private static final int MIN_HORIZONTAL_SPACING = 50;&#10;&#10;    public TreeVisualizationPanel() {&#10;        setBackground(new Color(248, 249, 250));&#10;        setPreferredSize(new Dimension(600, 400));&#10;        visitPath = new ArrayList&lt;&gt;();&#10;        currentVisitIndex = -1;&#10;    }&#10;&#10;    public void setTreeArray(Integer[] arr) {&#10;        this.treeArray = arr;&#10;        clearVisitPath();&#10;        repaint();&#10;    }&#10;&#10;    public void setVisitPath(java.util.List&lt;Integer&gt; path) {&#10;        this.visitPath = path;&#10;        this.currentVisitIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    public void showNextVisitStep() {&#10;        if (currentVisitIndex &lt; visitPath.size() - 1) {&#10;            currentVisitIndex++;&#10;            repaint();&#10;        }&#10;    }&#10;&#10;    public void clearVisitPath() {&#10;        this.visitPath.clear();&#10;        this.currentVisitIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    public boolean hasMoreSteps() {&#10;        return currentVisitIndex &lt; visitPath.size() - 1;&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        if (treeArray == null || treeArray.length &lt;= 1) return;&#10;&#10;        Graphics2D g2d = (Graphics2D) g.create();&#10;        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;&#10;        // 計算樹的最大層數&#10;        int maxLevel = (int) (Math.log(treeArray.length - 1) / Math.log(2)) + 1;&#10;&#10;        // 先畫連接線，再畫節點（避免線條覆蓋節點）&#10;        drawConnections(g2d, maxLevel);&#10;        drawNodes(g2d, maxLevel);&#10;&#10;        g2d.dispose();&#10;    }&#10;&#10;    private void drawConnections(Graphics2D g2d, int maxLevel) {&#10;        g2d.setColor(Color.BLACK);&#10;        g2d.setStroke(new BasicStroke(2));&#10;&#10;        for (int i = 1; i &lt; treeArray.length; i++) {&#10;            if (treeArray[i] == null) continue;&#10;&#10;            int leftChild = 2 * i;&#10;            int rightChild = 2 * i + 1;&#10;&#10;            Point parentPos = getNodePosition(i, maxLevel);&#10;&#10;            // 畫左子節點連線&#10;            if (leftChild &lt; treeArray.length &amp;&amp; treeArray[leftChild] != null) {&#10;                Point leftPos = getNodePosition(leftChild, maxLevel);&#10;                g2d.draw(new Line2D.Double(parentPos.x, parentPos.y, leftPos.x, leftPos.y));&#10;            }&#10;&#10;            // 畫右子節點連線&#10;            if (rightChild &lt; treeArray.length &amp;&amp; treeArray[rightChild] != null) {&#10;                Point rightPos = getNodePosition(rightChild, maxLevel);&#10;                g2d.draw(new Line2D.Double(parentPos.x, parentPos.y, rightPos.x, rightPos.y));&#10;            }&#10;        }&#10;    }&#10;&#10;    private void drawNodes(Graphics2D g2d, int maxLevel) {&#10;        for (int i = 1; i &lt; treeArray.length; i++) {&#10;            if (treeArray[i] == null) continue;&#10;&#10;            Point pos = getNodePosition(i, maxLevel);&#10;            boolean isRoot = (i == 1);&#10;            boolean isLeaf = isLeafNode(i);&#10;            boolean isCurrentVisit = currentVisitIndex &gt;= 0 &amp;&amp; currentVisitIndex &lt; visitPath.size()&#10;                                   &amp;&amp; visitPath.get(currentVisitIndex).equals(treeArray[i]);&#10;            boolean isVisited = isNodeVisited(treeArray[i]);&#10;&#10;            // 設定節點顏色&#10;            if (isCurrentVisit) {&#10;                g2d.setColor(new Color(255, 215, 0));  // 當前走訪節點：金黃色&#10;            } else if (isVisited) {&#10;                g2d.setColor(new Color(144, 238, 144));  // 已走訪節點：淡綠色&#10;            } else if (isRoot) {&#10;                g2d.setColor(Color.BLACK);  // 根節點黑色背景&#10;            } else if (isLeaf) {&#10;                g2d.setColor(Color.WHITE);  // 葉節點白色背景&#10;            } else {&#10;                g2d.setColor(new Color(200, 200, 200));  // 中間節點灰色背景&#10;            }&#10;&#10;            // 畫節點圓圈&#10;            Ellipse2D circle = new Ellipse2D.Double(&#10;                pos.x - NODE_RADIUS, pos.y - NODE_RADIUS,&#10;                2 * NODE_RADIUS, 2 * NODE_RADIUS&#10;            );&#10;            g2d.fill(circle);&#10;&#10;            // 畫節點邊框&#10;            if (isCurrentVisit) {&#10;                g2d.setColor(new Color(255, 140, 0));  // 當前節點橙色邊框&#10;                g2d.setStroke(new BasicStroke(4));&#10;            } else {&#10;                g2d.setColor(Color.BLACK);&#10;                g2d.setStroke(new BasicStroke(2));&#10;            }&#10;            g2d.draw(circle);&#10;&#10;            // 設定文字顏色&#10;            if (isRoot &amp;&amp; !isCurrentVisit &amp;&amp; !isVisited) {&#10;                g2d.setColor(Color.WHITE);  // 根節點白色文字&#10;            } else {&#10;                g2d.setColor(Color.BLACK);  // 其他節點黑色文字&#10;            }&#10;&#10;            // 畫節點值&#10;            String text = treeArray[i].toString();&#10;            FontMetrics fm = g2d.getFontMetrics();&#10;            int textWidth = fm.stringWidth(text);&#10;            int textHeight = fm.getAscent();&#10;            g2d.drawString(text,&#10;                pos.x - textWidth / 2,&#10;                pos.y + textHeight / 2 - 2);&#10;&#10;            // 畫陣列編號標示&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;            g2d.setColor(new Color(100, 100, 100));  // 灰色文字&#10;            String indexText = &quot;[&quot; + i + &quot;]&quot;;&#10;            FontMetrics indexFm = g2d.getFontMetrics();&#10;            int indexWidth = indexFm.stringWidth(indexText);&#10;            // 將編號放在節點右上角&#10;            g2d.drawString(indexText,&#10;                pos.x + NODE_RADIUS - indexWidth + 8,&#10;                pos.y - NODE_RADIUS + 12);&#10;            &#10;            // 恢復原本字體&#10;            g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        }&#10;    }&#10;&#10;    private boolean isNodeVisited(Integer value) {&#10;        for (int i = 0; i &lt;= currentVisitIndex &amp;&amp; i &lt; visitPath.size(); i++) {&#10;            if (visitPath.get(i).equals(value)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private Point getNodePosition(int index, int maxLevel) {&#10;        int level = (int) (Math.log(index) / Math.log(2));&#10;        int nodesInLevel = 1 &lt;&lt; level;&#10;        int positionInLevel = index - (1 &lt;&lt; level);&#10;&#10;        int panelWidth = getWidth();&#10;        int panelHeight = getHeight();&#10;&#10;        // 計算水平位置&#10;        int totalWidth = panelWidth - 2 * NODE_RADIUS;&#10;        int spacing = Math.max(MIN_HORIZONTAL_SPACING, totalWidth / (nodesInLevel + 1));&#10;        int x = NODE_RADIUS + spacing * (positionInLevel + 1);&#10;&#10;        // 確保節點在面板範圍內&#10;        if (nodesInLevel &gt; 1) {&#10;            x = NODE_RADIUS + (totalWidth * (positionInLevel + 1)) / (nodesInLevel + 1);&#10;        } else {&#10;            x = panelWidth / 2;&#10;        }&#10;&#10;        // 計算垂直位置&#10;        int y = NODE_RADIUS + 30 + level * LEVEL_HEIGHT;&#10;&#10;        return new Point(x, y);&#10;    }&#10;&#10;    private boolean isLeafNode(int index) {&#10;        int leftChild = 2 * index;&#10;        int rightChild = 2 * index + 1;&#10;&#10;        boolean hasLeftChild = leftChild &lt; treeArray.length &amp;&amp; treeArray[leftChild] != null;&#10;        boolean hasRightChild = rightChild &lt; treeArray.length &amp;&amp; treeArray[rightChild] != null;&#10;&#10;        return !hasLeftChild &amp;&amp; !hasRightChild;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0811-Graph/ArticulationPoints/src/ArticulationPointsPerformanceAnalysis.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0811-Graph/ArticulationPoints/src/ArticulationPointsPerformanceAnalysis.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0811-Graph/ArticulationPoints/src/PerformanceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0811-Graph/ArticulationPoints/src/PerformanceTest.java" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="import java.util.*;&#10;&#10;public class PerformanceTest {&#10;    &#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;割點算法性能測試&quot;);&#10;        System.out.println(&quot;=&quot;.repeat(60));&#10;        &#10;        // 測試不同規模的圖&#10;        int[] vertices = {10, 20, 50, 100, 200, 500, 1000};&#10;        double[] densities = {0.1, 0.3, 0.5, 0.7}; // 圖的密度 (邊數 / 最大可能邊數)&#10;        &#10;        System.out.printf(&quot;%-10s %-10s %-10s %-15s %-15s %-15s%n&quot;, &#10;                         &quot;Vertices&quot;, &quot;Edges&quot;, &quot;Density&quot;, &quot;Brute(ms)&quot;, &quot;Tarjan(ms)&quot;, &quot;Speedup&quot;);&#10;        System.out.println(&quot;-&quot;.repeat(80));&#10;        &#10;        for (int v : vertices) {&#10;            for (double density : densities) {&#10;                int maxEdges = v * (v - 1) / 2; // 完全圖的邊數&#10;                int edges = (int)(maxEdges * density);&#10;                &#10;                // 生成隨機圖&#10;                GraphGenerator generator = new GraphGenerator(v, edges);&#10;                List&lt;int[]&gt; edgeList = generator.generateConnectedGraph();&#10;                &#10;                // 測試暴力法&#10;                long bruteTime = testBruteForce(v, edgeList);&#10;                &#10;                // 測試 Tarjan 算法&#10;                long tarjanTime = testTarjan(v, edgeList);&#10;                &#10;                // 計算加速比&#10;                double speedup = (double)bruteTime / tarjanTime;&#10;                &#10;                System.out.printf(&quot;%-10d %-10d %-10.1f %-15d %-15d %-15.2fx%n&quot;, &#10;                                 v, edgeList.size(), density, bruteTime, tarjanTime, speedup);&#10;                &#10;                // 當暴力法時間過長時跳過更大的圖&#10;                if (bruteTime &gt; 5000) { // 超過5秒&#10;                    System.out.println(&quot;暴力法時間過長，跳過更大規模的測試&quot;);&#10;                    return;&#10;                }&#10;            }&#10;            System.out.println();&#10;        }&#10;        &#10;        System.out.println(&quot;\n結論分析:&quot;);&#10;        System.out.println(&quot;- 當圖規模較小時 (V &lt; 50)，兩种方法差異不大&quot;);&#10;        System.out.println(&quot;- 當圖規模較大時 (V &gt;= 100)，Tarjan 算法明顯更快&quot;);&#10;        System.out.println(&quot;- 建議: V &gt;= 50 或 E &gt;= 500 時使用 Tarjan 算法&quot;);&#10;    }&#10;    &#10;    private static long testBruteForce(int vertices, List&lt;int[]&gt; edges) {&#10;        BruteForceArticulationPoints brute = new BruteForceArticulationPoints(vertices);&#10;        &#10;        for (int[] edge : edges) {&#10;            brute.addEdge(edge[0], edge[1]);&#10;        }&#10;        &#10;        long startTime = System.nanoTime();&#10;        &#10;        // 執行多次測試取平均值&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            brute.findArticulationPoints();&#10;        }&#10;        &#10;        long endTime = System.nanoTime();&#10;        return (endTime - startTime) / 1_000_000 / 3; // 轉換為毫秒並取平均&#10;    }&#10;    &#10;    private static long testTarjan(int vertices, List&lt;int[]&gt; edges) {&#10;        TarjanArticulationPoints tarjan = new TarjanArticulationPoints(vertices);&#10;        &#10;        for (int[] edge : edges) {&#10;            tarjan.addEdge(edge[0], edge[1]);&#10;        }&#10;        &#10;        long startTime = System.nanoTime();&#10;        &#10;        // 執行多次測試取平均值&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            tarjan.findArticulationPoints();&#10;        }&#10;        &#10;        long endTime = System.nanoTime();&#10;        return (endTime - startTime) / 1_000_000 / 3; // 轉換為毫秒並取平均&#10;    }&#10;}&#10;&#10;// 圖生成器類別&#10;class GraphGenerator {&#10;    private int vertices;&#10;    private int targetEdges;&#10;    private Random random;&#10;    &#10;    public GraphGenerator(int vertices, int targetEdges) {&#10;        this.vertices = vertices;&#10;        this.targetEdges = targetEdges;&#10;        this.random = new Random(42); // 固定種子確保結果可重現&#10;    }&#10;    &#10;    public List&lt;int[]&gt; generateConnectedGraph() {&#10;        Set&lt;String&gt; edgeSet = new HashSet&lt;&gt;();&#10;        List&lt;int[]&gt; edges = new ArrayList&lt;&gt;();&#10;        &#10;        // 首先創建一個連通的生成樹&#10;        for (int i = 1; i &lt; vertices; i++) {&#10;            int parent = random.nextInt(i);&#10;            String edge = Math.min(i, parent) + &quot;-&quot; + Math.max(i, parent);&#10;            edgeSet.add(edge);&#10;            edges.add(new int[]{i, parent});&#10;        }&#10;        &#10;        // 添加額外的邊直到達到目標邊數&#10;        while (edges.size() &lt; targetEdges &amp;&amp; edges.size() &lt; vertices * (vertices - 1) / 2) {&#10;            int u = random.nextInt(vertices);&#10;            int v = random.nextInt(vertices);&#10;            &#10;            if (u != v) {&#10;                String edge = Math.min(u, v) + &quot;-&quot; + Math.max(u, v);&#10;                if (!edgeSet.contains(edge)) {&#10;                    edgeSet.add(edge);&#10;                    edges.add(new int[]{u, v});&#10;                }&#10;            }&#10;        }&#10;        &#10;        return edges;&#10;    }&#10;}&#10;&#10;// 暴力法&#10;class BruteForceArticulationPoints {&#10;    private int V;&#10;    private List&lt;List&lt;Integer&gt;&gt; adj;&#10;&#10;    public BruteForceArticulationPoints(int V) {&#10;        this.V = V;&#10;        adj = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; V; i++) adj.add(new ArrayList&lt;&gt;());&#10;    }&#10;&#10;    public void addEdge(int u, int v) {&#10;        adj.get(u).add(v);&#10;        adj.get(v).add(u);&#10;    }&#10;&#10;    private void dfs(int u, boolean[] visited, int skip) {&#10;        if (u == skip) return;&#10;        visited[u] = true;&#10;        for (int v : adj.get(u)) {&#10;            if (!visited[v] &amp;&amp; v != skip) dfs(v, visited, skip);&#10;        }&#10;    }&#10;&#10;    public Set&lt;Integer&gt; findArticulationPoints() {&#10;        Set&lt;Integer&gt; result = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; V; i++) {&#10;            boolean[] visited = new boolean[V];&#10;            int start = (i == 0) ? 1 : 0;&#10;            if (start &lt; V) {&#10;                dfs(start, visited, i);&#10;                for (int j = 0; j &lt; V; j++) {&#10;                    if (j != i &amp;&amp; !visited[j]) {&#10;                        result.add(i);&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;}&#10;&#10;// Tarjan 演算法&#10;class TarjanArticulationPoints {&#10;    private int V, time;&#10;    private List&lt;List&lt;Integer&gt;&gt; adj;&#10;    private boolean[] visited, isAP;&#10;    private int[] disc, low, parent;&#10;&#10;    public TarjanArticulationPoints(int V) {&#10;        this.V = V;&#10;        adj = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; V; i++) adj.add(new ArrayList&lt;&gt;());&#10;    }&#10;&#10;    public void addEdge(int u, int v) {&#10;        adj.get(u).add(v);&#10;        adj.get(v).add(u);&#10;    }&#10;&#10;    public Set&lt;Integer&gt; findArticulationPoints() {&#10;        time = 0;&#10;        visited = new boolean[V];&#10;        disc = new int[V];&#10;        low = new int[V];&#10;        parent = new int[V];&#10;        isAP = new boolean[V];&#10;        Arrays.fill(parent, -1);&#10;&#10;        for (int i = 0; i &lt; V; i++) {&#10;            if (!visited[i]) dfs(i);&#10;        }&#10;&#10;        Set&lt;Integer&gt; result = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; V; i++) if (isAP[i]) result.add(i);&#10;        return result;&#10;    }&#10;&#10;    private void dfs(int u) {&#10;        visited[u] = true;&#10;        disc[u] = low[u] = ++time;&#10;        int children = 0;&#10;        for (int v : adj.get(u)) {&#10;            if (!visited[v]) {&#10;                children++;&#10;                parent[v] = u;&#10;                dfs(v);&#10;                low[u] = Math.min(low[u], low[v]);&#10;                if (parent[u] == -1 &amp;&amp; children &gt; 1) isAP[u] = true;&#10;                if (parent[u] != -1 &amp;&amp; low[v] &gt;= disc[u]) isAP[u] = true;&#10;            } else if (v != parent[u]) {&#10;                low[u] = Math.min(low[u], disc[v]);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0811-Graph/ArticulationPoints/src/SimplePerformanceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0811-Graph/ArticulationPoints/src/SimplePerformanceTest.java" />
              <option name="updatedContent" value="import java.util.*;&#10;&#10;public class SimplePerformanceTest {&#10;    &#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;割點算法性能測試比較&quot;);&#10;        System.out.println(&quot;=&quot;.repeat(50));&#10;        &#10;        // 測試不同規模的圖&#10;        int[] testSizes = {10, 20, 30, 50, 100};&#10;        &#10;        System.out.printf(&quot;%-8s %-8s %-12s %-12s %-10s%n&quot;, &#10;                         &quot;節點數&quot;, &quot;邊數&quot;, &quot;暴力法(ms)&quot;, &quot;Tarjan(ms)&quot;, &quot;加速比&quot;);&#10;        System.out.println(&quot;-&quot;.repeat(50));&#10;        &#10;        for (int v : testSizes) {&#10;            // 創建稠密圖 (約50%密度)&#10;            int edgeCount = v * (v - 1) / 4; // 約一半的可能邊數&#10;            &#10;            // 生成測試圖&#10;            TestGraph graph = createTestGraph(v, edgeCount);&#10;            &#10;            // 測試暴力法&#10;            long bruteTime = testBruteForceMethod(graph);&#10;            &#10;            // 測試 Tarjan 算法  &#10;            long tarjanTime = testTarjanMethod(graph);&#10;            &#10;            // 計算加速比&#10;            double speedup = (tarjanTime == 0) ? 0 : (double)bruteTime / tarjanTime;&#10;            &#10;            System.out.printf(&quot;%-8d %-8d %-12d %-12d %-10.1fx%n&quot;, &#10;                             v, graph.edges.size(), bruteTime, tarjanTime, speedup);&#10;            &#10;            // 如果暴力法太慢就停止測試更大的圖&#10;            if (bruteTime &gt; 1000) {&#10;                System.out.println(&quot;\n暴力法時間過長，停止測試更大規模的圖&quot;);&#10;                break;&#10;            }&#10;        }&#10;        &#10;        System.out.println(&quot;\n性能分析結論:&quot;);&#10;        System.out.println(&quot;1. 小規模圖 (V ≤ 30): 兩種方法差異不大&quot;);&#10;        System.out.println(&quot;2. 中等規模圖 (30 &lt; V ≤ 100): Tarjan算法開始顯示優勢&quot;);&#10;        System.out.println(&quot;3. 大規模圖 (V &gt; 100): 強烈建議使用Tarjan算法&quot;);&#10;        System.out.println(&quot;\n建議使用原則:&quot;);&#10;        System.out.println(&quot;- 節點數 ≤ 50: 可使用暴力法 (實現簡單)&quot;);&#10;        System.out.println(&quot;- 節點數 &gt; 50: 建議使用Tarjan算法 (效能優異)&quot;);&#10;    }&#10;    &#10;    static class TestGraph {&#10;        int vertices;&#10;        List&lt;int[]&gt; edges;&#10;        &#10;        TestGraph(int v) {&#10;            vertices = v;&#10;            edges = new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;    &#10;    static TestGraph createTestGraph(int vertices, int targetEdges) {&#10;        TestGraph graph = new TestGraph(vertices);&#10;        Set&lt;String&gt; edgeSet = new HashSet&lt;&gt;();&#10;        Random rand = new Random(42); // 固定種子保證結果一致&#10;        &#10;        // 首先確保圖連通 - 創建生成樹&#10;        for (int i = 1; i &lt; vertices; i++) {&#10;            int parent = rand.nextInt(i);&#10;            String edgeKey = Math.min(i, parent) + &quot;-&quot; + Math.max(i, parent);&#10;            if (!edgeSet.contains(edgeKey)) {&#10;                edgeSet.add(edgeKey);&#10;                graph.edges.add(new int[]{i, parent});&#10;            }&#10;        }&#10;        &#10;        // 添加額外的邊&#10;        while (graph.edges.size() &lt; targetEdges) {&#10;            int u = rand.nextInt(vertices);&#10;            int v = rand.nextInt(vertices);&#10;            if (u != v) {&#10;                String edgeKey = Math.min(u, v) + &quot;-&quot; + Math.max(u, v);&#10;                if (!edgeSet.contains(edgeKey)) {&#10;                    edgeSet.add(edgeKey);&#10;                    graph.edges.add(new int[]{u, v});&#10;                }&#10;            }&#10;        }&#10;        &#10;        return graph;&#10;    }&#10;    &#10;    static long testBruteForceMethod(TestGraph graph) {&#10;        BruteForceAP bruteForce = new BruteForceAP(graph.vertices);&#10;        &#10;        // 建立圖&#10;        for (int[] edge : graph.edges) {&#10;            bruteForce.addEdge(edge[0], edge[1]);&#10;        }&#10;        &#10;        // 測試執行時間&#10;        long startTime = System.nanoTime();&#10;        bruteForce.findArticulationPoints();&#10;        long endTime = System.nanoTime();&#10;        &#10;        return (endTime - startTime) / 1_000_000; // 轉換為毫秒&#10;    }&#10;    &#10;    static long testTarjanMethod(TestGraph graph) {&#10;        TarjanAP tarjan = new TarjanAP(graph.vertices);&#10;        &#10;        // 建立圖&#10;        for (int[] edge : graph.edges) {&#10;            tarjan.addEdge(edge[0], edge[1]);&#10;        }&#10;        &#10;        // 測試執行時間&#10;        long startTime = System.nanoTime();&#10;        tarjan.findArticulationPoints();&#10;        long endTime = System.nanoTime();&#10;        &#10;        return (endTime - startTime) / 1_000_000; // 轉換為毫秒&#10;    }&#10;}&#10;&#10;// 暴力法實現&#10;class BruteForceAP {&#10;    private int V;&#10;    private List&lt;List&lt;Integer&gt;&gt; adj;&#10;&#10;    public BruteForceAP(int V) {&#10;        this.V = V;&#10;        adj = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; V; i++) {&#10;            adj.add(new ArrayList&lt;&gt;());&#10;        }&#10;    }&#10;&#10;    public void addEdge(int u, int v) {&#10;        adj.get(u).add(v);&#10;        adj.get(v).add(u);&#10;    }&#10;&#10;    private void dfs(int u, boolean[] visited, int skip) {&#10;        if (u == skip) return;&#10;        visited[u] = true;&#10;        for (int v : adj.get(u)) {&#10;            if (!visited[v] &amp;&amp; v != skip) {&#10;                dfs(v, visited, skip);&#10;            }&#10;        }&#10;    }&#10;&#10;    public Set&lt;Integer&gt; findArticulationPoints() {&#10;        Set&lt;Integer&gt; result = new HashSet&lt;&gt;();&#10;        &#10;        for (int i = 0; i &lt; V; i++) {&#10;            boolean[] visited = new boolean[V];&#10;            &#10;            // 找一個不是當前測試節點的起始點&#10;            int start = (i == 0) ? 1 : 0;&#10;            if (start &gt;= V) continue;&#10;            &#10;            // 從起始點開始DFS，跳過當前測試的節點&#10;            dfs(start, visited, i);&#10;            &#10;            // 檢查是否有節點無法訪問到&#10;            for (int j = 0; j &lt; V; j++) {&#10;                if (j != i &amp;&amp; !visited[j]) {&#10;                    result.add(i);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        &#10;        return result;&#10;    }&#10;}&#10;&#10;// Tarjan算法實現&#10;class TarjanAP {&#10;    private int V, time;&#10;    private List&lt;List&lt;Integer&gt;&gt; adj;&#10;    private boolean[] visited, isAP;&#10;    private int[] disc, low, parent;&#10;&#10;    public TarjanAP(int V) {&#10;        this.V = V;&#10;        adj = new ArrayList&lt;&gt;();&#10;        for (int i = 0; i &lt; V; i++) {&#10;            adj.add(new ArrayList&lt;&gt;());&#10;        }&#10;    }&#10;&#10;    public void addEdge(int u, int v) {&#10;        adj.get(u).add(v);&#10;        adj.get(v).add(u);&#10;    }&#10;&#10;    public Set&lt;Integer&gt; findArticulationPoints() {&#10;        // 初始化&#10;        time = 0;&#10;        visited = new boolean[V];&#10;        disc = new int[V];&#10;        low = new int[V];&#10;        parent = new int[V];&#10;        isAP = new boolean[V];&#10;        Arrays.fill(parent, -1);&#10;&#10;        // 對所有未訪問的節點執行DFS&#10;        for (int i = 0; i &lt; V; i++) {&#10;            if (!visited[i]) {&#10;                dfs(i);&#10;            }&#10;        }&#10;&#10;        // 收集所有割點&#10;        Set&lt;Integer&gt; result = new HashSet&lt;&gt;();&#10;        for (int i = 0; i &lt; V; i++) {&#10;            if (isAP[i]) {&#10;                result.add(i);&#10;            }&#10;        }&#10;        &#10;        return result;&#10;    }&#10;&#10;    private void dfs(int u) {&#10;        visited[u] = true;&#10;        disc[u] = low[u] = ++time;&#10;        int children = 0;&#10;&#10;        for (int v : adj.get(u)) {&#10;            if (!visited[v]) {&#10;                children++;&#10;                parent[v] = u;&#10;                dfs(v);&#10;&#10;                low[u] = Math.min(low[u], low[v]);&#10;&#10;                // 根節點是割點的條件：有超過一個子樹&#10;                if (parent[u] == -1 &amp;&amp; children &gt; 1) {&#10;                    isAP[u] = true;&#10;                }&#10;&#10;                // 非根節點是割點的條件：low[v] &gt;= disc[u]&#10;                if (parent[u] != -1 &amp;&amp; low[v] &gt;= disc[u]) {&#10;                    isAP[u] = true;&#10;                }&#10;            } else if (v != parent[u]) {&#10;                // 後向邊：更新low值&#10;                low[u] = Math.min(low[u], disc[v]);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0812-Graph/src/Graph.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0812-Graph/src/Graph.java" />
              <option name="originalContent" value="import java.awt.*;&#10;import java.util.*;&#10;import java.util.List;&#10;&#10;public class Graph {&#10;    private Map&lt;String, Point&gt; nodes = new HashMap&lt;&gt;();&#10;    private List&lt;Edge&gt; edges = new ArrayList&lt;&gt;();&#10;&#10;    public Map&lt;String, Point&gt; getNodes() {&#10;        return nodes;&#10;    }&#10;&#10;    public List&lt;Edge&gt; getEdges() {&#10;        return edges;&#10;    }&#10;&#10;    public void clear() {&#10;        nodes.clear();&#10;        edges.clear();&#10;    }&#10;&#10;    public void addNode(String name, Point p) {&#10;        nodes.put(name, p);&#10;    }&#10;&#10;    public void removeNode(String name) {&#10;        nodes.remove(name);&#10;        edges.removeIf(edge -&gt; edge.from.equals(name) || edge.to.equals(name));&#10;    }&#10;&#10;    public void addEdge(String from, String to) {&#10;        Random rand = new Random();&#10;        int cost = rand.nextInt(99) + 1; // 1~99&#10;        Edge edge = new Edge(from, to, cost);&#10;        if (!edges.contains(edge)) {&#10;            edges.add(edge);&#10;        }&#10;    }&#10;&#10;    public void addEdge(String from, String to, int cost) {&#10;        Edge edge = new Edge(from, to, cost);&#10;        if (!edges.contains(edge)) {&#10;            edges.add(edge);&#10;        }&#10;    }&#10;&#10;    public boolean containsNode(String name) {&#10;        return nodes.containsKey(name);&#10;    }&#10;&#10;    public int[][] getAdjacencyMatrix() {&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames); // 排序確保矩陣順序一致&#10;        int n = nodeNames.size();&#10;        int[][] matrix = new int[n][n];&#10;&#10;        // 初始化矩陣&#10;        for (int i = 0; i &lt; n; i++) {&#10;            for (int j = 0; j &lt; n; j++) {&#10;                matrix[i][j] = 0;&#10;            }&#10;        }&#10;&#10;        // 填入邊的權重&#10;        for (Edge edge : edges) {&#10;            int fromIndex = nodeNames.indexOf(edge.from);&#10;            int toIndex = nodeNames.indexOf(edge.to);&#10;            if (fromIndex &gt;= 0 &amp;&amp; toIndex &gt;= 0) {&#10;                matrix[fromIndex][toIndex] = edge.cost;&#10;                matrix[toIndex][fromIndex] = edge.cost; // 無向圖&#10;            }&#10;        }&#10;&#10;        return matrix;&#10;    }&#10;&#10;    public String getAdjacencyMatrixString() {&#10;        if (nodes.isEmpty()) return &quot;No nodes in graph&quot;;&#10;&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames);&#10;        int[][] matrix = getAdjacencyMatrix();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        // 標題行&#10;        sb.append(&quot;    &quot;);&#10;        for (String name : nodeNames) {&#10;            sb.append(String.format(&quot;%4s&quot;, name));&#10;        }&#10;        sb.append(&quot;\n&quot;);&#10;&#10;        // 矩陣行&#10;        for (int i = 0; i &lt; nodeNames.size(); i++) {&#10;            sb.append(String.format(&quot;%4s&quot;, nodeNames.get(i)));&#10;            for (int j = 0; j &lt; nodeNames.size(); j++) {&#10;                sb.append(String.format(&quot;%4d&quot;, matrix[i][j]));&#10;            }&#10;            sb.append(&quot;\n&quot;);&#10;        }&#10;&#10;        return sb.toString();&#10;    }&#10;&#10;    public Map&lt;String, List&lt;String&gt;&gt; getAdjacencyList() {&#10;        Map&lt;String, List&lt;String&gt;&gt; graph = new HashMap&lt;&gt;();&#10;        for (String name : nodes.keySet()) {&#10;            graph.put(name, new ArrayList&lt;&gt;());&#10;        }&#10;        for (Edge edge : edges) {&#10;            if (graph.containsKey(edge.from) &amp;&amp; graph.containsKey(edge.to)) {&#10;                graph.get(edge.from).add(edge.to);&#10;                graph.get(edge.to).add(edge.from);&#10;            }&#10;        }&#10;        return graph;&#10;    }&#10;&#10;    public List&lt;String&gt; dfs(String start) {&#10;        Map&lt;String, List&lt;String&gt;&gt; graph = getAdjacencyList();&#10;        List&lt;String&gt; result = new ArrayList&lt;&gt;();&#10;        Set&lt;String&gt; visited = new HashSet&lt;&gt;();&#10;        dfsHelper(start, graph, visited, result);&#10;        return result;&#10;    }&#10;&#10;    private void dfsHelper(String node, Map&lt;String, List&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, List&lt;String&gt; result) {&#10;        if (!visited.contains(node)) {&#10;            visited.add(node);&#10;            result.add(node);&#10;            for (String neighbor : graph.get(node)) {&#10;                dfsHelper(neighbor, graph, visited, result);&#10;            }&#10;        }&#10;    }&#10;&#10;    public List&lt;String&gt; bfs(String start) {&#10;        Map&lt;String, List&lt;String&gt;&gt; graph = getAdjacencyList();&#10;        List&lt;String&gt; result = new ArrayList&lt;&gt;();&#10;        Set&lt;String&gt; visited = new HashSet&lt;&gt;();&#10;        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();&#10;        queue.add(start);&#10;        visited.add(start);&#10;        while (!queue.isEmpty()) {&#10;            String node = queue.poll();&#10;            result.add(node);&#10;            for (String neighbor : graph.get(node)) {&#10;                if (!visited.contains(neighbor)) {&#10;                    queue.add(neighbor);&#10;                    visited.add(neighbor);&#10;                }&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    // Kruskal's algorithm for MST&#10;    public List&lt;Edge&gt; getMST() {&#10;        List&lt;Edge&gt; result = new ArrayList&lt;&gt;();&#10;        Map&lt;String, String&gt; parent = new HashMap&lt;&gt;();&#10;        for (String node : nodes.keySet()) parent.put(node, node);&#10;        List&lt;Edge&gt; sortedEdges = new ArrayList&lt;&gt;(edges);&#10;        sortedEdges.sort(Comparator.comparingInt(e -&gt; e.cost));&#10;        int count = 0;&#10;        for (Edge edge : sortedEdges) {&#10;            String root1 = find(parent, edge.from);&#10;            String root2 = find(parent, edge.to);&#10;            if (!root1.equals(root2)) {&#10;                result.add(edge);&#10;                parent.put(root1, root2);&#10;                count++;&#10;                if (count == nodes.size() - 1) break;&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    private String find(Map&lt;String, String&gt; parent, String node) {&#10;        if (!parent.get(node).equals(node)) {&#10;            parent.put(node, find(parent, parent.get(node)));&#10;        }&#10;        return parent.get(node);&#10;    }&#10;&#10;    // Dijkstra's algorithm for shortest path&#10;    public List&lt;Edge&gt; getShortestPath(String from, String to) {&#10;        Map&lt;String, Integer&gt; dist = new HashMap&lt;&gt;();&#10;        Map&lt;String, String&gt; prev = new HashMap&lt;&gt;();&#10;        for (String node : nodes.keySet()) dist.put(node, Integer.MAX_VALUE);&#10;        dist.put(from, 0);&#10;        PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(dist::get));&#10;        pq.add(from);&#10;&#10;        while (!pq.isEmpty()) {&#10;            String u = pq.poll();&#10;            for (Edge edge : edges) {&#10;                String v = null;&#10;                if (edge.from.equals(u)) v = edge.to;&#10;                else if (edge.to.equals(u)) v = edge.from;&#10;                if (v != null) {&#10;                    int alt = dist.get(u) + edge.cost;&#10;                    if (alt &lt; dist.get(v)) {&#10;                        dist.put(v, alt);&#10;                        prev.put(v, u);&#10;                        pq.add(v);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // 回溯路徑&#10;        List&lt;Edge&gt; path = new ArrayList&lt;&gt;();&#10;        String curr = to;&#10;        while (prev.containsKey(curr)) {&#10;            String p = prev.get(curr);&#10;            // 找到對應的邊&#10;            for (Edge edge : edges) {&#10;                if ((edge.from.equals(curr) &amp;&amp; edge.to.equals(p)) ||&#10;                    (edge.from.equals(p) &amp;&amp; edge.to.equals(curr))) {&#10;                    path.add(0, edge);&#10;                    break;&#10;                }&#10;            }&#10;            curr = p;&#10;        }&#10;        if (!from.equals(to) &amp;&amp; path.isEmpty()) return null; // 無路徑&#10;        return path;&#10;    }&#10;&#10;    // Floyd-Warshall Algorithm: 回傳所有點對點最短距離矩陣&#10;    public int[][] getFloydWarshallMatrix() {&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames);&#10;        int n = nodeNames.size();&#10;        int[][] dist = new int[n][n];&#10;        final int INF = 1000000000;&#10;        // 初始化&#10;        for (int i = 0; i &lt; n; i++) {&#10;            for (int j = 0; j &lt; n; j++) {&#10;                if (i == j) dist[i][j] = 0;&#10;                else dist[i][j] = INF;&#10;            }&#10;        }&#10;        for (Edge edge : edges) {&#10;            int u = nodeNames.indexOf(edge.from);&#10;            int v = nodeNames.indexOf(edge.to);&#10;            if (u &gt;= 0 &amp;&amp; v &gt;= 0) {&#10;                dist[u][v] = Math.min(dist[u][v], edge.cost);&#10;                dist[v][u] = Math.min(dist[v][u], edge.cost); // 無向圖&#10;            }&#10;        }&#10;        // Floyd-Warshall 主迴圈&#10;        for (int k = 0; k &lt; n; k++) {&#10;            for (int i = 0; i &lt; n; i++) {&#10;                for (int j = 0; j &lt; n; j++) {&#10;                    if (dist[i][k] &lt; INF &amp;&amp; dist[k][j] &lt; INF) {&#10;                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return dist;&#10;    }&#10;&#10;    // 輔助：回傳 Floyd-Warshall 結果字串&#10;    public String getFloydWarshallMatrixString() {&#10;        if (nodes.isEmpty()) return &quot;No nodes in graph&quot;;&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames);&#10;        int[][] dist = getFloydWarshallMatrix();&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        // 計算最大寬度以對齊&#10;        int maxWidth = 4;&#10;&#10;            sb.append(String.format(&quot;%&quot; + (maxWidth-1) + &quot;s |&quot;, nodeNames.get(i)));&#10;                String value = (dist[i][j] &gt;= 1000000000) ? &quot;INF&quot; : String.valueOf(dist[i][j]);&#10;                maxWidth = Math.max(maxWidth, value.length() + 1);&#10;            }&#10;        }&#10;&#10;            sb.append(String.format(&quot;%&quot; + (maxWidth-1) + &quot;s |&quot;, nodeNames.get(i)));&#10;        // 計算最大寬度以對齊&#10;                String value;&#10;                if (i == j) {&#10;                    value = &quot;0&quot;;&#10;                } else if (dist[i][j] &gt;= 1000000000) {&#10;                    value = &quot;∞&quot;;&#10;                } else {&#10;                    value = String.valueOf(dist[i][j]);&#10;&#10;        // 分隔線&#10;        sb.append(&quot;  &quot; + &quot;-&quot;.repeat(maxWidth * nodeNames.size() + maxWidth - 2)).append(&quot;\n&quot;);&#10;            sb.append(&quot;\n&quot;);&#10;            sb.append(&quot;\n&quot;);&#10;&#10;        sb.append(&quot;\n說明: 矩陣 [i][j] 表示從節點 i 到節點 j 的最短距離&quot;);&#10;        sb.append(&quot;\n      ∞ 表示無法到達&quot;);&#10;        sb.append(String.format(&quot;%&quot; + maxWidth + &quot;s&quot;, &quot;&quot;));&#10;        for (String name : nodeNames) {&#10;            sb.append(String.format(&quot;%&quot; + maxWidth + &quot;s&quot;, name));&#10;        }&#10;        sb.append(&quot;\n&quot;);&#10;&#10;        // 分隔線&#10;        sb.append(&quot;  &quot; + &quot;-&quot;.repeat(maxWidth * nodeNames.size() + maxWidth - 2)).append(&quot;\n&quot;);&#10;&#10;        // 矩陣行&#10;        for (int i = 0; i &lt; nodeNames.size(); i++) {&#10;            sb.append(String.format(&quot;%&quot; + (maxWidth-1) + &quot;s |&quot;, nodeNames.get(i)));&#10;            for (int j = 0; j &lt; nodeNames.size(); j++) {&#10;                String value;&#10;                if (i == j) {&#10;                    value = &quot;0&quot;;&#10;                } else if (dist[i][j] &gt;= 1000000000) {&#10;                    value = &quot;∞&quot;;&#10;                } else {&#10;                    value = String.valueOf(dist[i][j]);&#10;        // 分隔線&#10;        sb.append(&quot;  &quot; + &quot;-&quot;.repeat(maxWidth * nodeNames.size() + maxWidth - 2)).append(&quot;\n&quot;);&#10;            sb.append(&quot;\n&quot;);&#10;&#10;&#10;        sb.append(&quot;\n說明: 矩陣 [i][j] 表示從節點 i 到節點 j 的最短距離&quot;);&#10;        sb.append(&quot;\n      ∞ 表示無法到達&quot;);&#10;                sb.append(String.format(&quot;%&quot; + maxWidth + &quot;s&quot;, value));&#10;&#10;        // 標題行 - 節點名稱&#10;        sb.append(String.format(&quot;%&quot; + maxWidth + &quot;s&quot;, &quot;&quot;));&#10;        for (String name : nodeNames) {&#10;            sb.append(String.format(&quot;%&quot; + maxWidth + &quot;s&quot;, name));&#10;        }&#10;        sb.append(&quot;\n&quot;);&#10;&#10;        // 分隔線&#10;        sb.append(&quot;  &quot; + &quot;-&quot;.repeat(maxWidth * nodeNames.size() + maxWidth - 2)).append(&quot;\n&quot;);&#10;&#10;        // 矩陣行&#10;        for (int i = 0; i &lt; nodeNames.size(); i++) {&#10;            sb.append(String.format(&quot;%&quot; + (maxWidth-1) + &quot;s |&quot;, nodeNames.get(i)));&#10;            for (int j = 0; j &lt; nodeNames.size(); j++) {&#10;                String value;&#10;                if (i == j) {&#10;                    value = &quot;0&quot;;&#10;                } else if (dist[i][j] &gt;= 1000000000) {&#10;                    value = &quot;∞&quot;;&#10;                } else {&#10;                    value = String.valueOf(dist[i][j]);&#10;                }&#10;                sb.append(String.format(&quot;%&quot; + maxWidth + &quot;s&quot;, value));&#10;            }&#10;            sb.append(&quot;\n&quot;);&#10;        }&#10;&#10;        sb.append(&quot;\n說明: 矩陣 [i][j] 表示從節點 i 到節點 j 的最短距離&quot;);&#10;        sb.append(&quot;\n      ∞ 表示無法到達&quot;);&#10;        return sb.toString();&#10;    }&#10;&#10;    // 輔助：回傳 Floyd-Warshall 結果字串（僅矩陣，不含標題）&#10;    public String getFloydWarshallMatrixOnlyString() {&#10;        if (nodes.isEmpty()) return &quot;No nodes in graph&quot;;&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames);&#10;        int[][] dist = getFloydWarshallMatrix();&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int i = 0; i &lt; nodeNames.size(); i++) {&#10;            for (int j = 0; j &lt; nodeNames.size(); j++) {&#10;                if (dist[i][j] &gt;= 1000000000)&#10;                    sb.append(&quot;INF &quot;);&#10;                else&#10;                    sb.append(String.format(&quot;%3d &quot;, dist[i][j]));&#10;            }&#10;            sb.append(&quot;\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.awt.*;&#10;import java.util.*;&#10;import java.util.List;&#10;&#10;public class Graph {&#10;    private Map&lt;String, Point&gt; nodes = new HashMap&lt;&gt;();&#10;    private List&lt;Edge&gt; edges = new ArrayList&lt;&gt;();&#10;&#10;    public Map&lt;String, Point&gt; getNodes() {&#10;        return nodes;&#10;    }&#10;&#10;    public List&lt;Edge&gt; getEdges() {&#10;        return edges;&#10;    }&#10;&#10;    public void clear() {&#10;        nodes.clear();&#10;        edges.clear();&#10;    }&#10;&#10;    public void addNode(String name, Point p) {&#10;        nodes.put(name, p);&#10;    }&#10;&#10;    public void removeNode(String name) {&#10;        nodes.remove(name);&#10;        edges.removeIf(edge -&gt; edge.from.equals(name) || edge.to.equals(name));&#10;    }&#10;&#10;    public void addEdge(String from, String to) {&#10;        Random rand = new Random();&#10;        int cost = rand.nextInt(99) + 1; // 1~99&#10;        Edge edge = new Edge(from, to, cost);&#10;        if (!edges.contains(edge)) {&#10;            edges.add(edge);&#10;        }&#10;    }&#10;&#10;    public void addEdge(String from, String to, int cost) {&#10;        Edge edge = new Edge(from, to, cost);&#10;        if (!edges.contains(edge)) {&#10;            edges.add(edge);&#10;        }&#10;    }&#10;&#10;    public boolean containsNode(String name) {&#10;        return nodes.containsKey(name);&#10;    }&#10;&#10;    public int[][] getAdjacencyMatrix() {&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames); // 排序確保矩陣順序一致&#10;        int n = nodeNames.size();&#10;        int[][] matrix = new int[n][n];&#10;&#10;        // 初始化矩陣&#10;        for (int i = 0; i &lt; n; i++) {&#10;            for (int j = 0; j &lt; n; j++) {&#10;                matrix[i][j] = 0;&#10;            }&#10;        }&#10;&#10;        // 填入邊的權重&#10;        for (Edge edge : edges) {&#10;            int fromIndex = nodeNames.indexOf(edge.from);&#10;            int toIndex = nodeNames.indexOf(edge.to);&#10;            if (fromIndex &gt;= 0 &amp;&amp; toIndex &gt;= 0) {&#10;                matrix[fromIndex][toIndex] = edge.cost;&#10;                matrix[toIndex][fromIndex] = edge.cost; // 無向圖&#10;            }&#10;        }&#10;&#10;        return matrix;&#10;    }&#10;&#10;    public String getAdjacencyMatrixString() {&#10;        if (nodes.isEmpty()) return &quot;No nodes in graph&quot;;&#10;&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames);&#10;        int[][] matrix = getAdjacencyMatrix();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        // 標題行&#10;        sb.append(&quot;    &quot;);&#10;        for (String name : nodeNames) {&#10;            sb.append(String.format(&quot;%4s&quot;, name));&#10;        }&#10;        sb.append(&quot;\n&quot;);&#10;&#10;        // 矩陣行&#10;        for (int i = 0; i &lt; nodeNames.size(); i++) {&#10;            sb.append(String.format(&quot;%4s&quot;, nodeNames.get(i)));&#10;            for (int j = 0; j &lt; nodeNames.size(); j++) {&#10;                sb.append(String.format(&quot;%4d&quot;, matrix[i][j]));&#10;            }&#10;            sb.append(&quot;\n&quot;);&#10;        }&#10;&#10;        return sb.toString();&#10;    }&#10;&#10;    public Map&lt;String, List&lt;String&gt;&gt; getAdjacencyList() {&#10;        Map&lt;String, List&lt;String&gt;&gt; graph = new HashMap&lt;&gt;();&#10;        for (String name : nodes.keySet()) {&#10;            graph.put(name, new ArrayList&lt;&gt;());&#10;        }&#10;        for (Edge edge : edges) {&#10;            if (graph.containsKey(edge.from) &amp;&amp; graph.containsKey(edge.to)) {&#10;                graph.get(edge.from).add(edge.to);&#10;                graph.get(edge.to).add(edge.from);&#10;            }&#10;        }&#10;        return graph;&#10;    }&#10;&#10;    public List&lt;String&gt; dfs(String start) {&#10;        Map&lt;String, List&lt;String&gt;&gt; graph = getAdjacencyList();&#10;        List&lt;String&gt; result = new ArrayList&lt;&gt;();&#10;        Set&lt;String&gt; visited = new HashSet&lt;&gt;();&#10;        dfsHelper(start, graph, visited, result);&#10;        return result;&#10;    }&#10;&#10;    private void dfsHelper(String node, Map&lt;String, List&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, List&lt;String&gt; result) {&#10;        if (!visited.contains(node)) {&#10;            visited.add(node);&#10;            result.add(node);&#10;            for (String neighbor : graph.get(node)) {&#10;                dfsHelper(neighbor, graph, visited, result);&#10;            }&#10;        }&#10;    }&#10;&#10;    public List&lt;String&gt; bfs(String start) {&#10;        Map&lt;String, List&lt;String&gt;&gt; graph = getAdjacencyList();&#10;        List&lt;String&gt; result = new ArrayList&lt;&gt;();&#10;        Set&lt;String&gt; visited = new HashSet&lt;&gt;();&#10;        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();&#10;        queue.add(start);&#10;        visited.add(start);&#10;        while (!queue.isEmpty()) {&#10;            String node = queue.poll();&#10;            result.add(node);&#10;            for (String neighbor : graph.get(node)) {&#10;                if (!visited.contains(neighbor)) {&#10;                    queue.add(neighbor);&#10;                    visited.add(neighbor);&#10;                }&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    // Kruskal's algorithm for MST&#10;    public List&lt;Edge&gt; getMST() {&#10;        List&lt;Edge&gt; result = new ArrayList&lt;&gt;();&#10;        Map&lt;String, String&gt; parent = new HashMap&lt;&gt;();&#10;        for (String node : nodes.keySet()) parent.put(node, node);&#10;        List&lt;Edge&gt; sortedEdges = new ArrayList&lt;&gt;(edges);&#10;        sortedEdges.sort(Comparator.comparingInt(e -&gt; e.cost));&#10;        int count = 0;&#10;        for (Edge edge : sortedEdges) {&#10;            String root1 = find(parent, edge.from);&#10;            String root2 = find(parent, edge.to);&#10;            if (!root1.equals(root2)) {&#10;                result.add(edge);&#10;                parent.put(root1, root2);&#10;                count++;&#10;                if (count == nodes.size() - 1) break;&#10;            }&#10;        }&#10;        return result;&#10;    }&#10;&#10;    private String find(Map&lt;String, String&gt; parent, String node) {&#10;        if (!parent.get(node).equals(node)) {&#10;            parent.put(node, find(parent, parent.get(node)));&#10;        }&#10;        return parent.get(node);&#10;    }&#10;&#10;    // Dijkstra's algorithm for shortest path&#10;    public List&lt;Edge&gt; getShortestPath(String from, String to) {&#10;        Map&lt;String, Integer&gt; dist = new HashMap&lt;&gt;();&#10;        Map&lt;String, String&gt; prev = new HashMap&lt;&gt;();&#10;        for (String node : nodes.keySet()) dist.put(node, Integer.MAX_VALUE);&#10;        dist.put(from, 0);&#10;        PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(dist::get));&#10;        pq.add(from);&#10;&#10;        while (!pq.isEmpty()) {&#10;            String u = pq.poll();&#10;            for (Edge edge : edges) {&#10;                String v = null;&#10;                if (edge.from.equals(u)) v = edge.to;&#10;                else if (edge.to.equals(u)) v = edge.from;&#10;                if (v != null) {&#10;                    int alt = dist.get(u) + edge.cost;&#10;                    if (alt &lt; dist.get(v)) {&#10;                        dist.put(v, alt);&#10;                        prev.put(v, u);&#10;                        pq.add(v);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // 回溯路徑&#10;        List&lt;Edge&gt; path = new ArrayList&lt;&gt;();&#10;        String curr = to;&#10;        while (prev.containsKey(curr)) {&#10;            String p = prev.get(curr);&#10;            // 找到對應的邊&#10;            for (Edge edge : edges) {&#10;                if ((edge.from.equals(curr) &amp;&amp; edge.to.equals(p)) ||&#10;                    (edge.from.equals(p) &amp;&amp; edge.to.equals(curr))) {&#10;                    path.add(0, edge);&#10;                    break;&#10;                }&#10;            }&#10;            curr = p;&#10;        }&#10;        if (!from.equals(to) &amp;&amp; path.isEmpty()) return null; // 無路徑&#10;        return path;&#10;    }&#10;&#10;    // Floyd-Warshall Algorithm: 回傳所有點對點最短距離矩陣&#10;    public int[][] getFloydWarshallMatrix() {&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames);&#10;        int n = nodeNames.size();&#10;        int[][] dist = new int[n][n];&#10;        final int INF = 1000000000;&#10;        // 初始化&#10;        for (int i = 0; i &lt; n; i++) {&#10;            for (int j = 0; j &lt; n; j++) {&#10;                if (i == j) dist[i][j] = 0;&#10;                else dist[i][j] = INF;&#10;            }&#10;        }&#10;        for (Edge edge : edges) {&#10;            int u = nodeNames.indexOf(edge.from);&#10;            int v = nodeNames.indexOf(edge.to);&#10;            if (u &gt;= 0 &amp;&amp; v &gt;= 0) {&#10;                dist[u][v] = Math.min(dist[u][v], edge.cost);&#10;                dist[v][u] = Math.min(dist[v][u], edge.cost); // 無向圖&#10;            }&#10;        }&#10;        // Floyd-Warshall 主迴圈&#10;        for (int k = 0; k &lt; n; k++) {&#10;            for (int i = 0; i &lt; n; i++) {&#10;                for (int j = 0; j &lt; n; j++) {&#10;                    if (dist[i][k] &lt; INF &amp;&amp; dist[k][j] &lt; INF) {&#10;                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return dist;&#10;    }&#10;&#10;    // 輔助：回傳 Floyd-Warshall 結果字串&#10;    public String getFloydWarshallMatrixString() {&#10;        if (nodes.isEmpty()) return &quot;No nodes in graph&quot;;&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames);&#10;        int[][] dist = getFloydWarshallMatrix();&#10;        StringBuilder sb = new StringBuilder();&#10;        &#10;        // 標題&#10;        sb.append(&quot;Floyd-Warshall 最短路徑矩陣\n&quot;);&#10;        sb.append(&quot;========================================\n&quot;);&#10;        sb.append(&quot;節點數量: &quot;).append(nodeNames.size()).append(&quot;\n&quot;);&#10;        sb.append(&quot;========================================\n\n&quot;);&#10;        &#10;        // 條列式顯示所有頂點對的最短距離&#10;        int pairCount = 0;&#10;        for (int i = 0; i &lt; nodeNames.size(); i++) {&#10;            for (int j = 0; j &lt; nodeNames.size(); j++) {&#10;                if (i != j) { // 排除自己到自己的距離&#10;                    pairCount++;&#10;                    String from = nodeNames.get(i);&#10;                    String to = nodeNames.get(j);&#10;                    if (dist[i][j] &gt;= 1000000000) {&#10;                        sb.append(String.format(&quot;%s -&gt; %s：無法到達\n&quot;, from, to));&#10;                    } else {&#10;                        sb.append(String.format(&quot;%s -&gt; %s：%d\n&quot;, from, to, dist[i][j]));&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        sb.append(&quot;\n========================================&quot;);&#10;        sb.append(String.format(&quot;\n共有 %d 個頂點對的最短路徑&quot;, pairCount));&#10;        sb.append(&quot;\n說明: 列表顯示所有頂點對之間的最短距離&quot;);&#10;        sb.append(&quot;\n      「無法到達」表示兩點間沒有連通路徑&quot;);&#10;        &#10;        return sb.toString();&#10;    }&#10;&#10;    // 輔助：回傳 Floyd-Warshall 結果字串（僅矩陣，不含標題）&#10;    public String getFloydWarshallMatrixOnlyString() {&#10;        if (nodes.isEmpty()) return &quot;No nodes in graph&quot;;&#10;        List&lt;String&gt; nodeNames = new ArrayList&lt;&gt;(nodes.keySet());&#10;        Collections.sort(nodeNames);&#10;        int[][] dist = getFloydWarshallMatrix();&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int i = 0; i &lt; nodeNames.size(); i++) {&#10;            for (int j = 0; j &lt; nodeNames.size(); j++) {&#10;                if (dist[i][j] &gt;= 1000000000)&#10;                    sb.append(&quot;INF &quot;);&#10;                else&#10;                    sb.append(String.format(&quot;%3d &quot;, dist[i][j]));&#10;            }&#10;            sb.append(&quot;\n&quot;);&#10;        }&#10;        return sb.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0818-Sort/src/StockRankGUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0818-Sort/src/StockRankGUI.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import javax.swing.border.Border;&#10;import javax.swing.border.TitledBorder;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.io.BufferedReader;&#10;import java.io.FileReader;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class StockRankGUI extends JFrame {&#10;    private JTextField stockCodeField;&#10;    private JTextField startDateField;&#10;    private JTextField endDateField;&#10;    private JTextField kField;&#10;    private JButton searchButton;&#10;    private JTextArea resultArea;&#10;    private JLabel timeLabel;&#10;    private JLabel marketStatusLabel;&#10;    private javax.swing.Timer clockTimer;&#10;&#10;    // 排序方式選擇按鈕&#10;    private JRadioButton sortByAmountButton;&#10;    private JRadioButton sortByVolumeButton;&#10;&#10;    // 股票終端機色彩主題&#10;    private static final Color TERMINAL_BLACK = new Color(0, 0, 0);&#10;    private static final Color TERMINAL_GREEN = new Color(0, 255, 0);&#10;    private static final Color TERMINAL_AMBER = new Color(255, 191, 0);&#10;    private static final Color TERMINAL_RED = new Color(255, 0, 0);&#10;    private static final Color TERMINAL_CYAN = new Color(0, 255, 255);&#10;    private static final Color TERMINAL_GRAY = new Color(64, 64, 64);&#10;    private static final Color TERMINAL_DARK_GREEN = new Color(0, 128, 0);&#10;&#10;    public StockRankGUI() {&#10;        setTitle(&quot;股票交易終端機 - Bloomberg Terminal Style v2.0&quot;);&#10;        setSize(1000, 700);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setResizable(true);&#10;&#10;        // 設置黑色終端機背景&#10;        getContentPane().setBackground(TERMINAL_BLACK);&#10;        setLayout(new BorderLayout(5, 5));&#10;&#10;        //  啟動時自動生成測試資料&#10;        generateTestDataOnStartup();&#10;&#10;        // 創建頂部標題和時鐘面板&#10;        JPanel headerPanel = createHeaderPanel();&#10;        add(headerPanel, BorderLayout.NORTH);&#10;&#10;        // 创建输入面板&#10;        JPanel inputPanel = createInputPanel();&#10;        add(inputPanel, BorderLayout.WEST);&#10;&#10;        // 创建结果显示面板&#10;        JPanel resultPanel = createResultPanel();&#10;        add(resultPanel, BorderLayout.CENTER);&#10;&#10;        // 创建状态栏&#10;        JPanel statusPanel = createStatusPanel();&#10;        add(statusPanel, BorderLayout.SOUTH);&#10;&#10;        // 居中顯示窗口&#10;        setLocationRelativeTo(null);&#10;&#10;        // 添加事件監聽器&#10;        searchButton.addActionListener(e -&gt; performSearch());&#10;&#10;        // 啟動時鐘&#10;        startClock();&#10;&#10;        // 自動載入並設置日期範圍&#10;        loadDateRange();&#10;    }&#10;&#10;    /**&#10;     * 啟動時自動生成測試資料&#10;     */&#10;    private void generateTestDataOnStartup() {&#10;        System.out.println(&quot; 正在生成測試資料...&quot;);&#10;&#10;        // 確保 src 目錄存在&#10;        java.io.File srcDir = new java.io.File(&quot;src&quot;);&#10;        if (!srcDir.exists()) {&#10;            srcDir.mkdirs();&#10;            System.out.println(&quot; 創建 src 目錄&quot;);&#10;        }&#10;&#10;        boolean success = TestDataGenerator.generateTestData(&quot;src/testdata.csv&quot;);&#10;        if (success) {&#10;            System.out.println(&quot;✅ 測試資料生成完成，位於：src/testdata.csv&quot;);&#10;        } else {&#10;            System.err.println(&quot;❌ 測試資料生成失敗！&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadDateRange() {&#10;        // 在背景執行緒中載入日期範圍，避免阻塞 UI&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            String[] dateRange = getDateRangeFromCSV();&#10;            if (dateRange != null) {&#10;                startDateField.setText(dateRange[0]);&#10;                endDateField.setText(dateRange[1]);&#10;                startDateField.setToolTipText(&quot;資料最早日期: &quot; + dateRange[0]);&#10;                endDateField.setToolTipText(&quot;資料最晚日期: &quot; + dateRange[1]);&#10;            }&#10;        });&#10;    }&#10;&#10;    private String[] getDateRangeFromCSV() {&#10;        String minDate = null;&#10;        String maxDate = null;&#10;&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;src/testdata.csv&quot;))) {&#10;            br.readLine(); // skip header&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length &gt;= 2) {&#10;                    String date = parts[1];&#10;                    if (minDate == null || date.compareTo(minDate) &lt; 0) {&#10;                        minDate = date;&#10;                    }&#10;                    if (maxDate == null || date.compareTo(maxDate) &gt; 0) {&#10;                        maxDate = date;&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;無法載入日期範圍: &quot; + e.getMessage());&#10;            // 如果無法讀取檔案，使用預設範圍&#10;            return new String[]{&quot;2023-01-01&quot;, &quot;2024-03-08&quot;};&#10;        }&#10;&#10;        return new String[]{minDate, maxDate};&#10;    }&#10;&#10;    private JPanel createHeaderPanel() {&#10;        JPanel headerPanel = new JPanel(new BorderLayout());&#10;        headerPanel.setBackground(TERMINAL_BLACK);&#10;        headerPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 5, 10));&#10;&#10;        // 左側：系統標題&#10;        JLabel titleLabel = new JLabel(&quot;█ STOCK TRADING TERMINAL █&quot;);&#10;        titleLabel.setFont(new Font(&quot;Courier New&quot;, Font.BOLD, 16));&#10;        titleLabel.setForeground(TERMINAL_CYAN);&#10;&#10;        // 中間：市場狀態&#10;        marketStatusLabel = new JLabel(&quot;Market: OPEN&quot;);&#10;        marketStatusLabel.setFont(new Font(&quot;Courier New&quot;, Font.BOLD, 12));&#10;        marketStatusLabel.setForeground(TERMINAL_GREEN);&#10;        marketStatusLabel.setHorizontalAlignment(SwingConstants.CENTER);&#10;&#10;        // 右側：時間顯示&#10;        timeLabel = new JLabel();&#10;        timeLabel.setFont(new Font(&quot;Courier New&quot;, Font.BOLD, 12));&#10;        timeLabel.setForeground(TERMINAL_AMBER);&#10;&#10;        headerPanel.add(titleLabel, BorderLayout.WEST);&#10;        headerPanel.add(marketStatusLabel, BorderLayout.CENTER);&#10;        headerPanel.add(timeLabel, BorderLayout.EAST);&#10;&#10;        return headerPanel;&#10;    }&#10;&#10;    private void startClock() {&#10;        clockTimer = new javax.swing.Timer(1000, e -&gt; {&#10;            java.time.LocalDateTime now = java.time.LocalDateTime.now();&#10;            String timeStr = now.format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));&#10;            timeLabel.setText(timeStr);&#10;&#10;            // 模擬市場狀態&#10;            int hour = now.getHour();&#10;            if (hour &gt;= 9 &amp;&amp; hour &lt; 14) {&#10;                marketStatusLabel.setText(&quot;Market: OPEN&quot;);&#10;                marketStatusLabel.setForeground(TERMINAL_GREEN);&#10;            } else {&#10;                marketStatusLabel.setText(&quot;Market: CLOSED&quot;);&#10;                marketStatusLabel.setForeground(TERMINAL_RED);&#10;            }&#10;        });&#10;        clockTimer.start();&#10;&#10;        // 立即更新一次時間&#10;        clockTimer.getActionListeners()[0].actionPerformed(null);&#10;    }&#10;&#10;    private JPanel createInputPanel() {&#10;        JPanel mainPanel = new JPanel();&#10;        mainPanel.setBackground(TERMINAL_BLACK);&#10;        mainPanel.setLayout(new BorderLayout(5, 5));&#10;        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 5, 10));&#10;&#10;        // 创建分组框&#10;        JPanel inputGroup = new JPanel();&#10;        inputGroup.setBackground(TERMINAL_BLACK);&#10;        Border etchedBorder = BorderFactory.createEtchedBorder();&#10;        TitledBorder titledBorder = BorderFactory.createTitledBorder(etchedBorder, &quot;查詢條件&quot;);&#10;        titledBorder.setTitleFont(new Font(&quot;MS Sans Serif&quot;, Font.BOLD, 11));&#10;        titledBorder.setTitleColor(TERMINAL_GREEN);&#10;        inputGroup.setBorder(titledBorder);&#10;&#10;        // 使用 GridBagLayout 获得更好的控制&#10;        inputGroup.setLayout(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 10, 5, 5);&#10;&#10;        // 添加输入字段&#10;        Font labelFont = new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11);&#10;        Font fieldFont = new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11);&#10;&#10;        // 股票代号&#10;        gbc.gridx = 0; gbc.gridy = 0; gbc.anchor = GridBagConstraints.WEST;&#10;        JLabel stockLabel = new JLabel(&quot;股票代號(可留空):&quot;);&#10;        stockLabel.setFont(labelFont);&#10;        stockLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(stockLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        stockCodeField = createWin31TextField();&#10;        stockCodeField.setFont(fieldFont);&#10;        inputGroup.add(stockCodeField, gbc);&#10;&#10;        // 开始日期&#10;        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 1; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;&#10;        JLabel startLabel = new JLabel(&quot;開始日期(yyyy-MM-dd):&quot;);&#10;        startLabel.setFont(labelFont);&#10;        startLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(startLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        startDateField = createWin31TextField();&#10;        startDateField.setFont(fieldFont);&#10;        inputGroup.add(startDateField, gbc);&#10;&#10;        // 结束日期&#10;        gbc.gridx = 0; gbc.gridy = 3; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;&#10;        JLabel endLabel = new JLabel(&quot;結束日期(yyyy-MM-dd):&quot;);&#10;        endLabel.setFont(labelFont);&#10;        endLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(endLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        endDateField = createWin31TextField();&#10;        endDateField.setFont(fieldFont);&#10;        inputGroup.add(endDateField, gbc);&#10;&#10;        // 資料日期範圍提示&#10;        gbc.gridx = 0; gbc.gridy = 1; gbc.gridwidth = 2; gbc.fill = GridBagConstraints.HORIZONTAL;&#10;        JLabel dateRangeLabel = new JLabel(&quot;資料範圍: 2023-01-01 至 2024-03-08&quot;);&#10;        dateRangeLabel.setFont(new Font(&quot;MS Sans Serif&quot;, Font.ITALIC, 10));&#10;        dateRangeLabel.setForeground(TERMINAL_AMBER);&#10;        dateRangeLabel.setHorizontalAlignment(SwingConstants.CENTER);&#10;        inputGroup.add(dateRangeLabel, gbc);&#10;&#10;        // 排序方式選擇&#10;        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 1; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;&#10;        JLabel sortLabel = new JLabel(&quot;排序方式:&quot;);&#10;        sortLabel.setFont(labelFont);&#10;        sortLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(sortLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        JPanel sortPanel = createSortPanel();&#10;        inputGroup.add(sortPanel, gbc);&#10;&#10;        // 排名数量&#10;        gbc.gridx = 0; gbc.gridy = 5; gbc.gridwidth = 1; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;&#10;        JLabel kLabel = new JLabel(&quot;排名數量:&quot;);&#10;        kLabel.setFont(labelFont);&#10;        kLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(kLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        kField = createWin31TextField();&#10;        kField.setFont(fieldFont);&#10;        kField.setText(&quot;10&quot;);&#10;        inputGroup.add(kField, gbc);&#10;&#10;        mainPanel.add(inputGroup, BorderLayout.CENTER);&#10;&#10;        // 添加查询按钮&#10;        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));&#10;        buttonPanel.setBackground(TERMINAL_BLACK);&#10;        searchButton = createWin31Button(&quot;查詢排行榜&quot;);&#10;        buttonPanel.add(searchButton);&#10;        mainPanel.add(buttonPanel, BorderLayout.SOUTH);&#10;&#10;        return mainPanel;&#10;    }&#10;&#10;    private JPanel createResultPanel() {&#10;        JPanel panel = new JPanel(new BorderLayout(5, 5));&#10;        panel.setBackground(TERMINAL_BLACK);&#10;        panel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));&#10;&#10;        // 创建结果显示分组&#10;        JPanel resultGroup = new JPanel(new BorderLayout());&#10;        resultGroup.setBackground(TERMINAL_BLACK);&#10;        Border etchedBorder = BorderFactory.createEtchedBorder();&#10;        TitledBorder titledBorder = BorderFactory.createTitledBorder(etchedBorder, &quot;查詢結果&quot;);&#10;        titledBorder.setTitleFont(new Font(&quot;MS Sans Serif&quot;, Font.BOLD, 11));&#10;        titledBorder.setTitleColor(TERMINAL_GREEN);&#10;        resultGroup.setBorder(titledBorder);&#10;&#10;        resultArea = new JTextArea();&#10;        resultArea.setEditable(false);&#10;        resultArea.setFont(new Font(&quot;Courier New&quot;, Font.PLAIN, 11));&#10;        resultArea.setBackground(TERMINAL_GRAY);&#10;        resultArea.setForeground(TERMINAL_GREEN);&#10;        resultArea.setBorder(BorderFactory.createLoweredBevelBorder());&#10;&#10;        JScrollPane scrollPane = new JScrollPane(resultArea);&#10;        scrollPane.setBorder(BorderFactory.createLoweredBevelBorder());&#10;        scrollPane.setBackground(TERMINAL_BLACK);&#10;&#10;        resultGroup.add(scrollPane, BorderLayout.CENTER);&#10;        panel.add(resultGroup, BorderLayout.CENTER);&#10;&#10;        return panel;&#10;    }&#10;&#10;    private JPanel createStatusPanel() {&#10;        JPanel statusPanel = new JPanel(new BorderLayout());&#10;        statusPanel.setBackground(TERMINAL_BLACK);&#10;        statusPanel.setBorder(BorderFactory.createLoweredBevelBorder());&#10;        statusPanel.setPreferredSize(new Dimension(0, 25));&#10;&#10;        JLabel statusLabel = new JLabel(&quot; 就緒&quot;);&#10;        statusLabel.setFont(new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11));&#10;        statusLabel.setForeground(TERMINAL_GREEN);&#10;        statusPanel.add(statusLabel, BorderLayout.WEST);&#10;&#10;        return statusPanel;&#10;    }&#10;&#10;    private JTextField createWin31TextField() {&#10;        JTextField field = new JTextField();&#10;        field.setBorder(BorderFactory.createLoweredBevelBorder());&#10;        field.setBackground(TERMINAL_GRAY);&#10;        field.setForeground(TERMINAL_GREEN);&#10;        field.setPreferredSize(new Dimension(150, 22));&#10;        return field;&#10;    }&#10;&#10;    private JButton createWin31Button(String text) {&#10;        JButton button = new JButton(text);&#10;        button.setFont(new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11));&#10;        button.setBackground(TERMINAL_BLACK);&#10;        button.setForeground(TERMINAL_GREEN);&#10;        button.setBorder(BorderFactory.createRaisedBevelBorder());&#10;        button.setPreferredSize(new Dimension(120, 28));&#10;        button.setFocusPainted(false);&#10;&#10;        // 添加鼠标效果&#10;        button.addMouseListener(new java.awt.event.MouseAdapter() {&#10;            public void mousePressed(java.awt.event.MouseEvent evt) {&#10;                button.setBorder(BorderFactory.createLoweredBevelBorder());&#10;            }&#10;            public void mouseReleased(java.awt.event.MouseEvent evt) {&#10;                button.setBorder(BorderFactory.createRaisedBevelBorder());&#10;            }&#10;        });&#10;&#10;        return button;&#10;    }&#10;&#10;    private JPanel createSortPanel() {&#10;        JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        panel.setBackground(TERMINAL_BLACK);&#10;        panel.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));&#10;&#10;        sortByAmountButton = new JRadioButton(&quot;按成交金額&quot;);&#10;        sortByVolumeButton = new JRadioButton(&quot;按成交量&quot;);&#10;        ButtonGroup sortGroup = new ButtonGroup();&#10;        sortGroup.add(sortByAmountButton);&#10;        sortGroup.add(sortByVolumeButton);&#10;&#10;        sortByAmountButton.setFont(new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11));&#10;        sortByVolumeButton.setFont(new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11));&#10;&#10;        sortByAmountButton.setForeground(TERMINAL_GREEN);&#10;        sortByVolumeButton.setForeground(TERMINAL_GREEN);&#10;&#10;        sortByAmountButton.setBackground(TERMINAL_BLACK);&#10;        sortByVolumeButton.setBackground(TERMINAL_BLACK);&#10;&#10;        sortByAmountButton.setSelected(true); // 默認按成交金額排序&#10;&#10;        panel.add(sortByAmountButton);&#10;        panel.add(sortByVolumeButton);&#10;&#10;        return panel;&#10;    }&#10;&#10;    private void performSearch() {&#10;        String stockCode = stockCodeField.getText().trim();&#10;        String startDate = startDateField.getText().trim();&#10;        String endDate = endDateField.getText().trim();&#10;        int k;&#10;        try {&#10;            k = Integer.parseInt(kField.getText().trim());&#10;        } catch (Exception ex) {&#10;            resultArea.setText(&quot;重新輸入排名總數&quot;);&#10;            return;&#10;        }&#10;        List&lt;StockRecord&gt; filtered = filterRecords(stockCode, startDate, endDate);&#10;        String result = getTopK(filtered, k);&#10;        resultArea.setText(result);&#10;    }&#10;&#10;    private List&lt;StockRecord&gt; filterRecords(String stockCode, String startDate, String endDate) {&#10;        List&lt;StockRecord&gt; result = new ArrayList&lt;&gt;();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;src/testdata.csv&quot;))) {&#10;            br.readLine(); // skip header&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length != 4) continue;&#10;                String code = parts[0];&#10;                String date = parts[1];&#10;                long volume = Long.parseLong(parts[2]);&#10;                long amount = Long.parseLong(parts[3]);&#10;                if (!stockCode.isEmpty() &amp;&amp; !code.equals(stockCode)) continue;&#10;                if (!startDate.isEmpty() &amp;&amp; date.compareTo(startDate) &lt; 0) continue;&#10;                if (!endDate.isEmpty() &amp;&amp; date.compareTo(endDate) &gt; 0) continue;&#10;                result.add(new StockRecord(code, date, volume, amount));&#10;            }&#10;        } catch (Exception e) {&#10;            resultArea.setText(&quot;資料讀取失敗: &quot; + e.getMessage());&#10;        }&#10;        return result;&#10;    }&#10;&#10;    private String getTopK(List&lt;StockRecord&gt; records, int k) {&#10;        // 以成交金額排序，取前K名&#10;        records.sort((a, b) -&gt; Long.compare(b.getAmount(), a.getAmount()));&#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        // 終端機風格的標題欄&#10;        sb.append(&quot;╔═══════════════════════════════════════════════════════════════════════════════╗\n&quot;);&#10;        sb.append(&quot;║                        股票交易排行榜 - TRADING TERMINAL                         ║\n&quot;);&#10;        sb.append(&quot;╠═══════════╦══════════════╦══════════════════╦══════════════════════════════════╣\n&quot;);&#10;        sb.append(&quot;║  股票代碼  ║   交易日期    ║     成交量        ║         成交金額 (NT$)             ║\n&quot;);&#10;        sb.append(&quot;╠═══════════╬══════════════╬══════════════════╬══════════════════════════════════╣\n&quot;);&#10;&#10;        for (int i = 0; i &lt; Math.min(k, records.size()); i++) {&#10;            StockRecord r = records.get(i);&#10;            // 格式化數字顯示，加入千分位逗號&#10;            String formattedVolume = String.format(&quot;%,d&quot;, r.getVolume());&#10;            String formattedAmount = String.format(&quot;%,d&quot;, r.getAmount());&#10;&#10;            sb.append(String.format(&quot;║ %9s ║ %12s ║ %16s ║ %32s ║\n&quot;,&#10;                r.getStockCode(),&#10;                r.getTradeDate(),&#10;                formattedVolume,&#10;                formattedAmount));&#10;        }&#10;&#10;        sb.append(&quot;╚═══════════╩══════════════╩══════════════════╩══════════════════════════════════╝\n&quot;);&#10;        sb.append(String.format(&quot;\n&gt;&gt;&gt; 顯示前 %d 名股票 | 總計 %d 筆記錄 | 查詢時間: %s &lt;&lt;&lt;\n&quot;,&#10;            Math.min(k, records.size()),&#10;            records.size(),&#10;            java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))));&#10;&#10;        return sb.toString();&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        // 设置外观，不依赖特定的 Look and Feel&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            StockRankGUI gui = new StockRankGUI();&#10;            gui.setVisible(true);&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import javax.swing.border.Border;&#10;import javax.swing.border.TitledBorder;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.io.BufferedReader;&#10;import java.io.FileReader;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class StockRankGUI extends JFrame {&#10;    private JTextField stockCodeField;&#10;    private JTextField startDateField;&#10;    private JTextField endDateField;&#10;    private JTextField kField;&#10;    private JButton searchButton;&#10;    private JTextArea resultArea;&#10;    private JLabel timeLabel;&#10;    private JLabel marketStatusLabel;&#10;    private javax.swing.Timer clockTimer;&#10;&#10;    // 排序方式選擇按鈕&#10;    private JRadioButton sortByAmountButton;&#10;    private JRadioButton sortByVolumeButton;&#10;&#10;    // 股票終端機色彩主題&#10;    private static final Color TERMINAL_BLACK = new Color(0, 0, 0);&#10;    private static final Color TERMINAL_GREEN = new Color(0, 255, 0);&#10;    private static final Color TERMINAL_AMBER = new Color(255, 191, 0);&#10;    private static final Color TERMINAL_RED = new Color(255, 0, 0);&#10;    private static final Color TERMINAL_CYAN = new Color(0, 255, 255);&#10;    private static final Color TERMINAL_GRAY = new Color(64, 64, 64);&#10;    private static final Color TERMINAL_DARK_GREEN = new Color(0, 128, 0);&#10;&#10;    public StockRankGUI() {&#10;        setTitle(&quot;股票交易終端機 - Bloomberg Terminal Style v2.0&quot;);&#10;        setSize(1000, 700);&#10;        setDefaultCloseOperation(EXIT_ON_CLOSE);&#10;        setResizable(true);&#10;&#10;        // 設置黑色終端機背景&#10;        getContentPane().setBackground(TERMINAL_BLACK);&#10;        setLayout(new BorderLayout(5, 5));&#10;&#10;        //  啟動時自動生成測試資料&#10;        generateTestDataOnStartup();&#10;&#10;        // 創建頂部標題和時鐘面板&#10;        JPanel headerPanel = createHeaderPanel();&#10;        add(headerPanel, BorderLayout.NORTH);&#10;&#10;        // 创建输入面板&#10;        JPanel inputPanel = createInputPanel();&#10;        add(inputPanel, BorderLayout.WEST);&#10;&#10;        // 创建结果显示面板&#10;        JPanel resultPanel = createResultPanel();&#10;        add(resultPanel, BorderLayout.CENTER);&#10;&#10;        // 创建状态栏&#10;        JPanel statusPanel = createStatusPanel();&#10;        add(statusPanel, BorderLayout.SOUTH);&#10;&#10;        // 居中顯示窗口&#10;        setLocationRelativeTo(null);&#10;&#10;        // 添加事件監聽器&#10;        searchButton.addActionListener(e -&gt; performSearch());&#10;&#10;        // 啟動時鐘&#10;        startClock();&#10;&#10;        // 自動載入並設置日期範圍&#10;        loadDateRange();&#10;    }&#10;&#10;    /**&#10;     * 啟動時自動生成測試資料&#10;     */&#10;    private void generateTestDataOnStartup() {&#10;        System.out.println(&quot; 正在生成測試資料...&quot;);&#10;&#10;        // 確保 src 目錄存在&#10;        java.io.File srcDir = new java.io.File(&quot;src&quot;);&#10;        if (!srcDir.exists()) {&#10;            srcDir.mkdirs();&#10;            System.out.println(&quot; 創建 src 目錄&quot;);&#10;        }&#10;&#10;        boolean success = TestDataGenerator.generateTestData(&quot;src/testdata.csv&quot;);&#10;        if (success) {&#10;            System.out.println(&quot;✅ 測試資料生成完成，位於：src/testdata.csv&quot;);&#10;        } else {&#10;            System.err.println(&quot;❌ 測試資料生成失敗！&quot;);&#10;        }&#10;    }&#10;&#10;    private void loadDateRange() {&#10;        // 在背景執行緒中載入日期範圍，避免阻塞 UI&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            String[] dateRange = getDateRangeFromCSV();&#10;            if (dateRange != null) {&#10;                startDateField.setText(dateRange[0]);&#10;                endDateField.setText(dateRange[1]);&#10;                startDateField.setToolTipText(&quot;資料最早日期: &quot; + dateRange[0]);&#10;                endDateField.setToolTipText(&quot;資料最晚日期: &quot; + dateRange[1]);&#10;            }&#10;        });&#10;    }&#10;&#10;    private String[] getDateRangeFromCSV() {&#10;        String minDate = null;&#10;        String maxDate = null;&#10;&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;src/testdata.csv&quot;))) {&#10;            br.readLine(); // skip header&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length &gt;= 2) {&#10;                    String date = parts[1];&#10;                    if (minDate == null || date.compareTo(minDate) &lt; 0) {&#10;                        minDate = date;&#10;                    }&#10;                    if (maxDate == null || date.compareTo(maxDate) &gt; 0) {&#10;                        maxDate = date;&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;無法載入日期範圍: &quot; + e.getMessage());&#10;            // 如果無法讀取檔案，使用預設範圍&#10;            return new String[]{&quot;2023-01-01&quot;, &quot;2024-03-08&quot;};&#10;        }&#10;&#10;        return new String[]{minDate, maxDate};&#10;    }&#10;&#10;    private JPanel createHeaderPanel() {&#10;        JPanel headerPanel = new JPanel(new BorderLayout());&#10;        headerPanel.setBackground(TERMINAL_BLACK);&#10;        headerPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 5, 10));&#10;&#10;        // 左側：系統標題&#10;        JLabel titleLabel = new JLabel(&quot;█ STOCK TRADING TERMINAL █&quot;);&#10;        titleLabel.setFont(new Font(&quot;Courier New&quot;, Font.BOLD, 16));&#10;        titleLabel.setForeground(TERMINAL_CYAN);&#10;&#10;        // 中間：市場狀態&#10;        marketStatusLabel = new JLabel(&quot;Market: OPEN&quot;);&#10;        marketStatusLabel.setFont(new Font(&quot;Courier New&quot;, Font.BOLD, 12));&#10;        marketStatusLabel.setForeground(TERMINAL_GREEN);&#10;        marketStatusLabel.setHorizontalAlignment(SwingConstants.CENTER);&#10;&#10;        // 右側：時間顯示&#10;        timeLabel = new JLabel();&#10;        timeLabel.setFont(new Font(&quot;Courier New&quot;, Font.BOLD, 12));&#10;        timeLabel.setForeground(TERMINAL_AMBER);&#10;&#10;        headerPanel.add(titleLabel, BorderLayout.WEST);&#10;        headerPanel.add(marketStatusLabel, BorderLayout.CENTER);&#10;        headerPanel.add(timeLabel, BorderLayout.EAST);&#10;&#10;        return headerPanel;&#10;    }&#10;&#10;    private void startClock() {&#10;        clockTimer = new javax.swing.Timer(1000, e -&gt; {&#10;            java.time.LocalDateTime now = java.time.LocalDateTime.now();&#10;            String timeStr = now.format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));&#10;            timeLabel.setText(timeStr);&#10;&#10;            // 模擬市場狀態&#10;            int hour = now.getHour();&#10;            if (hour &gt;= 9 &amp;&amp; hour &lt; 14) {&#10;                marketStatusLabel.setText(&quot;Market: OPEN&quot;);&#10;                marketStatusLabel.setForeground(TERMINAL_GREEN);&#10;            } else {&#10;                marketStatusLabel.setText(&quot;Market: CLOSED&quot;);&#10;                marketStatusLabel.setForeground(TERMINAL_RED);&#10;            }&#10;        });&#10;        clockTimer.start();&#10;&#10;        // 立即更新一次時間&#10;        clockTimer.getActionListeners()[0].actionPerformed(null);&#10;    }&#10;&#10;    private JPanel createInputPanel() {&#10;        JPanel mainPanel = new JPanel();&#10;        mainPanel.setBackground(TERMINAL_BLACK);&#10;        mainPanel.setLayout(new BorderLayout(5, 5));&#10;        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 5, 10));&#10;&#10;        // 创建分组框&#10;        JPanel inputGroup = new JPanel();&#10;        inputGroup.setBackground(TERMINAL_BLACK);&#10;        Border etchedBorder = BorderFactory.createEtchedBorder();&#10;        TitledBorder titledBorder = BorderFactory.createTitledBorder(etchedBorder, &quot;查詢條件&quot;);&#10;        titledBorder.setTitleFont(new Font(&quot;MS Sans Serif&quot;, Font.BOLD, 11));&#10;        titledBorder.setTitleColor(TERMINAL_GREEN);&#10;        inputGroup.setBorder(titledBorder);&#10;&#10;        // 使用 GridBagLayout 获得更好的控制&#10;        inputGroup.setLayout(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 10, 5, 5);&#10;&#10;        // 添加输入字段&#10;        Font labelFont = new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11);&#10;        Font fieldFont = new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11);&#10;&#10;        // 股票代号&#10;        gbc.gridx = 0; gbc.gridy = 0; gbc.anchor = GridBagConstraints.WEST;&#10;        JLabel stockLabel = new JLabel(&quot;股票代號(可留空):&quot;);&#10;        stockLabel.setFont(labelFont);&#10;        stockLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(stockLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        stockCodeField = createWin31TextField();&#10;        stockCodeField.setFont(fieldFont);&#10;        inputGroup.add(stockCodeField, gbc);&#10;&#10;        // 开始日期&#10;        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 1; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;&#10;        JLabel startLabel = new JLabel(&quot;開始日期(yyyy-MM-dd):&quot;);&#10;        startLabel.setFont(labelFont);&#10;        startLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(startLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        startDateField = createWin31TextField();&#10;        startDateField.setFont(fieldFont);&#10;        inputGroup.add(startDateField, gbc);&#10;&#10;        // 结束日期&#10;        gbc.gridx = 0; gbc.gridy = 3; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;&#10;        JLabel endLabel = new JLabel(&quot;結束日期(yyyy-MM-dd):&quot;);&#10;        endLabel.setFont(labelFont);&#10;        endLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(endLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        endDateField = createWin31TextField();&#10;        endDateField.setFont(fieldFont);&#10;        inputGroup.add(endDateField, gbc);&#10;&#10;        // 資料日期範圍提示&#10;        gbc.gridx = 0; gbc.gridy = 1; gbc.gridwidth = 2; gbc.fill = GridBagConstraints.HORIZONTAL;&#10;        JLabel dateRangeLabel = new JLabel(&quot;資料範圍: 2023-01-01 至 2024-03-08&quot;);&#10;        dateRangeLabel.setFont(new Font(&quot;MS Sans Serif&quot;, Font.ITALIC, 10));&#10;        dateRangeLabel.setForeground(TERMINAL_AMBER);&#10;        dateRangeLabel.setHorizontalAlignment(SwingConstants.CENTER);&#10;        inputGroup.add(dateRangeLabel, gbc);&#10;&#10;        // 排序方式選擇&#10;        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 1; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;&#10;        JLabel sortLabel = new JLabel(&quot;排序方式:&quot;);&#10;        sortLabel.setFont(labelFont);&#10;        sortLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(sortLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        JPanel sortPanel = createSortPanel();&#10;        inputGroup.add(sortPanel, gbc);&#10;&#10;        // 排名数量&#10;        gbc.gridx = 0; gbc.gridy = 5; gbc.gridwidth = 1; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;&#10;        JLabel kLabel = new JLabel(&quot;排名數量:&quot;);&#10;        kLabel.setFont(labelFont);&#10;        kLabel.setForeground(TERMINAL_GREEN);&#10;        inputGroup.add(kLabel, gbc);&#10;&#10;        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;&#10;        kField = createWin31TextField();&#10;        kField.setFont(fieldFont);&#10;        kField.setText(&quot;10&quot;);&#10;        inputGroup.add(kField, gbc);&#10;&#10;        mainPanel.add(inputGroup, BorderLayout.CENTER);&#10;&#10;        // 添加查询按钮&#10;        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));&#10;        buttonPanel.setBackground(TERMINAL_BLACK);&#10;        searchButton = createWin31Button(&quot;查詢排行榜&quot;);&#10;        buttonPanel.add(searchButton);&#10;        mainPanel.add(buttonPanel, BorderLayout.SOUTH);&#10;&#10;        return mainPanel;&#10;    }&#10;&#10;    private JPanel createResultPanel() {&#10;        JPanel panel = new JPanel(new BorderLayout(5, 5));&#10;        panel.setBackground(TERMINAL_BLACK);&#10;        panel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));&#10;&#10;        // 创建结果显示分组&#10;        JPanel resultGroup = new JPanel(new BorderLayout());&#10;        resultGroup.setBackground(TERMINAL_BLACK);&#10;        Border etchedBorder = BorderFactory.createEtchedBorder();&#10;        TitledBorder titledBorder = BorderFactory.createTitledBorder(etchedBorder, &quot;查詢結果&quot;);&#10;        titledBorder.setTitleFont(new Font(&quot;MS Sans Serif&quot;, Font.BOLD, 11));&#10;        titledBorder.setTitleColor(TERMINAL_GREEN);&#10;        resultGroup.setBorder(titledBorder);&#10;&#10;        resultArea = new JTextArea();&#10;        resultArea.setEditable(false);&#10;        resultArea.setFont(new Font(&quot;Courier New&quot;, Font.PLAIN, 11));&#10;        resultArea.setBackground(TERMINAL_GRAY);&#10;        resultArea.setForeground(TERMINAL_GREEN);&#10;        resultArea.setBorder(BorderFactory.createLoweredBevelBorder());&#10;&#10;        JScrollPane scrollPane = new JScrollPane(resultArea);&#10;        scrollPane.setBorder(BorderFactory.createLoweredBevelBorder());&#10;        scrollPane.setBackground(TERMINAL_BLACK);&#10;&#10;        resultGroup.add(scrollPane, BorderLayout.CENTER);&#10;        panel.add(resultGroup, BorderLayout.CENTER);&#10;&#10;        return panel;&#10;    }&#10;&#10;    private JPanel createStatusPanel() {&#10;        JPanel statusPanel = new JPanel(new BorderLayout());&#10;        statusPanel.setBackground(TERMINAL_BLACK);&#10;        statusPanel.setBorder(BorderFactory.createLoweredBevelBorder());&#10;        statusPanel.setPreferredSize(new Dimension(0, 25));&#10;&#10;        JLabel statusLabel = new JLabel(&quot; 就緒&quot;);&#10;        statusLabel.setFont(new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11));&#10;        statusLabel.setForeground(TERMINAL_GREEN);&#10;        statusPanel.add(statusLabel, BorderLayout.WEST);&#10;&#10;        return statusPanel;&#10;    }&#10;&#10;    private JTextField createWin31TextField() {&#10;        JTextField field = new JTextField();&#10;        field.setBorder(BorderFactory.createLoweredBevelBorder());&#10;        field.setBackground(TERMINAL_GRAY);&#10;        field.setForeground(TERMINAL_GREEN);&#10;        field.setPreferredSize(new Dimension(150, 22));&#10;        return field;&#10;    }&#10;&#10;    private JButton createWin31Button(String text) {&#10;        JButton button = new JButton(text);&#10;        button.setFont(new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11));&#10;        button.setBackground(TERMINAL_BLACK);&#10;        button.setForeground(TERMINAL_GREEN);&#10;        button.setBorder(BorderFactory.createRaisedBevelBorder());&#10;        button.setPreferredSize(new Dimension(120, 28));&#10;        button.setFocusPainted(false);&#10;&#10;        // 添加鼠标效果&#10;        button.addMouseListener(new java.awt.event.MouseAdapter() {&#10;            public void mousePressed(java.awt.event.MouseEvent evt) {&#10;                button.setBorder(BorderFactory.createLoweredBevelBorder());&#10;            }&#10;            public void mouseReleased(java.awt.event.MouseEvent evt) {&#10;                button.setBorder(BorderFactory.createRaisedBevelBorder());&#10;            }&#10;        });&#10;&#10;        return button;&#10;    }&#10;&#10;    private JPanel createSortPanel() {&#10;        JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        panel.setBackground(TERMINAL_BLACK);&#10;        panel.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));&#10;&#10;        sortByAmountButton = new JRadioButton(&quot;按成交金額&quot;);&#10;        sortByVolumeButton = new JRadioButton(&quot;按成交量&quot;);&#10;        ButtonGroup sortGroup = new ButtonGroup();&#10;        sortGroup.add(sortByAmountButton);&#10;        sortGroup.add(sortByVolumeButton);&#10;&#10;        sortByAmountButton.setFont(new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11));&#10;        sortByVolumeButton.setFont(new Font(&quot;MS Sans Serif&quot;, Font.PLAIN, 11));&#10;&#10;        sortByAmountButton.setForeground(TERMINAL_GREEN);&#10;        sortByVolumeButton.setForeground(TERMINAL_GREEN);&#10;&#10;        sortByAmountButton.setBackground(TERMINAL_BLACK);&#10;        sortByVolumeButton.setBackground(TERMINAL_BLACK);&#10;&#10;        sortByAmountButton.setSelected(true); // 默認按成交金額排序&#10;&#10;        panel.add(sortByAmountButton);&#10;        panel.add(sortByVolumeButton);&#10;&#10;        return panel;&#10;    }&#10;&#10;    private void performSearch() {&#10;        String stockCode = stockCodeField.getText().trim();&#10;        String startDate = startDateField.getText().trim();&#10;        String endDate = endDateField.getText().trim();&#10;        int k;&#10;        try {&#10;            k = Integer.parseInt(kField.getText().trim());&#10;        } catch (Exception ex) {&#10;            resultArea.setText(&quot;重新輸入排名總數&quot;);&#10;            return;&#10;        }&#10;        List&lt;StockRecord&gt; filtered = filterRecords(stockCode, startDate, endDate);&#10;        String result = getTopK(filtered, k);&#10;        resultArea.setText(result);&#10;    }&#10;&#10;    private List&lt;StockRecord&gt; filterRecords(String stockCode, String startDate, String endDate) {&#10;        List&lt;StockRecord&gt; result = new ArrayList&lt;&gt;();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;src/testdata.csv&quot;))) {&#10;            br.readLine(); // skip header&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length != 4) continue;&#10;                String code = parts[0];&#10;                String date = parts[1];&#10;                long volume = Long.parseLong(parts[2]);&#10;                long amount = Long.parseLong(parts[3]);&#10;                if (!stockCode.isEmpty() &amp;&amp; !code.equals(stockCode)) continue;&#10;                if (!startDate.isEmpty() &amp;&amp; date.compareTo(startDate) &lt; 0) continue;&#10;                if (!endDate.isEmpty() &amp;&amp; date.compareTo(endDate) &gt; 0) continue;&#10;                result.add(new StockRecord(code, date, volume, amount));&#10;            }&#10;        } catch (Exception e) {&#10;            resultArea.setText(&quot;資料讀取失敗: &quot; + e.getMessage());&#10;        }&#10;        return result;&#10;    }&#10;&#10;    private String getTopK(List&lt;StockRecord&gt; records, int k) {&#10;        // 根據使用者選擇的排序方式進行排序&#10;        boolean sortByAmount = sortByAmountButton.isSelected();&#10;        String sortType = sortByAmount ? &quot;成交金額&quot; : &quot;成交量&quot;;&#10;        &#10;        if (sortByAmount) {&#10;            // 按成交金額排序（由高到低）&#10;            records.sort((a, b) -&gt; Long.compare(b.getAmount(), a.getAmount()));&#10;        } else {&#10;            // 按成交量排序（由高到低）&#10;            records.sort((a, b) -&gt; Long.compare(b.getVolume(), a.getVolume()));&#10;        }&#10;        &#10;        StringBuilder sb = new StringBuilder();&#10;&#10;        // 終端機風格的標題欄，顯示排序方式&#10;        sb.append(&quot;╔═══════════════════════════════════════════════════════════════════════════════╗\n&quot;);&#10;        sb.append(String.format(&quot;║                    股票交易排行榜 - 按%s排序                     ║\n&quot;, sortType));&#10;        sb.append(&quot;╠═══════════╦══════════════╦══════════════════╦══════════════════════════════════╣\n&quot;);&#10;        sb.append(&quot;║  股票代碼  ║   交易日期    ║     成交量        ║         成交金額 (NT$)             ║\n&quot;);&#10;        sb.append(&quot;╠═══════════╬══════════════╬══════════════════╬══════════════════════════════════╣\n&quot;);&#10;&#10;        for (int i = 0; i &lt; Math.min(k, records.size()); i++) {&#10;            StockRecord r = records.get(i);&#10;            // 格式化數字顯示，加入千分位逗號&#10;            String formattedVolume = String.format(&quot;%,d&quot;, r.getVolume());&#10;            String formattedAmount = String.format(&quot;%,d&quot;, r.getAmount());&#10;&#10;            sb.append(String.format(&quot;║ %9s ║ %12s ║ %16s ║ %32s ║\n&quot;,&#10;                r.getStockCode(),&#10;                r.getTradeDate(),&#10;                formattedVolume,&#10;                formattedAmount));&#10;        }&#10;&#10;        sb.append(&quot;╚═══════════╩══════════════╩══════════════════╩══════════════════════════════════╝\n&quot;);&#10;        sb.append(String.format(&quot;\n&gt;&gt;&gt; 按%s顯示前 %d 名股票 | 總計 %d 筆記錄 | 查詢時間: %s &lt;&lt;&lt;\n&quot;,&#10;            sortType,&#10;            Math.min(k, records.size()),&#10;            records.size(),&#10;            java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))));&#10;&#10;        return sb.toString();&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        // 设置外观，不依赖特定的 Look and Feel&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            StockRankGUI gui = new StockRankGUI();&#10;            gui.setVisible(true);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/0818-Sort/src/TestDataGenerator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/0818-Sort/src/TestDataGenerator.java" />
              <option name="updatedContent" value="import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.time.LocalDate;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.Random;&#10;&#10;/**&#10; * 測試資料生成器&#10; * 自動產生400個交易日期、1800檔股票的資料檔&#10; */&#10;public class TestDataGenerator {&#10;    private static final int STOCK_COUNT = 1800;     // 股票數量&#10;    private static final int TRADING_DAYS = 400;     // 交易日期數量&#10;    private static final Random random = new Random();&#10;    &#10;    /**&#10;     * 生成測試資料並寫入指定路徑&#10;     * @param filePath 檔案路徑&#10;     * @return 是否成功生成&#10;     */&#10;    public static boolean generateTestData(String filePath) {&#10;        try (FileWriter writer = new FileWriter(filePath)) {&#10;            // 寫入標題行&#10;            writer.write(&quot;stockCode,tradeDate,volume,amount\n&quot;);&#10;            &#10;            // 生成起始日期（從2023-01-01開始）&#10;            LocalDate startDate = LocalDate.of(2023, 1, 1);&#10;            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;            &#10;            // 生成交易日期（排除週末）&#10;            LocalDate[] tradingDates = generateTradingDates(startDate, TRADING_DAYS);&#10;            &#10;            // 為每個交易日期生成所有股票的資料&#10;            for (LocalDate date : tradingDates) {&#10;                for (int stockNum = 1; stockNum &lt;= STOCK_COUNT; stockNum++) {&#10;                    String stockCode = String.format(&quot;%04d&quot;, stockNum);&#10;                    String dateStr = date.format(formatter);&#10;                    long volume = generateRandomVolume();&#10;                    long amount = generateRandomAmount();&#10;                    &#10;                    writer.write(String.format(&quot;%s,%s,%d,%d\n&quot;, &#10;                        stockCode, dateStr, volume, amount));&#10;                }&#10;            }&#10;            &#10;            System.out.println(&quot;✅ 測試資料生成完成：&quot; + filePath);&#10;            System.out.println(&quot; 資料統計：&quot;);&#10;            System.out.println(&quot;   - 股票數量：&quot; + STOCK_COUNT + &quot; 檔&quot;);&#10;            System.out.println(&quot;   - 交易日期：&quot; + TRADING_DAYS + &quot; 天&quot;);&#10;            System.out.println(&quot;   - 總記錄數：&quot; + (STOCK_COUNT * TRADING_DAYS) + &quot; 筆&quot;);&#10;            &#10;            return true;&#10;            &#10;        } catch (IOException e) {&#10;            System.err.println(&quot;❌ 資料生成失敗：&quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * 生成交易日期（排除週末）&#10;     */&#10;    private static LocalDate[] generateTradingDates(LocalDate startDate, int count) {&#10;        LocalDate[] dates = new LocalDate[count];&#10;        LocalDate current = startDate;&#10;        int index = 0;&#10;        &#10;        while (index &lt; count) {&#10;            // 排除週六(6)和週日(7)&#10;            if (current.getDayOfWeek().getValue() &lt;= 5) {&#10;                dates[index] = current;&#10;                index++;&#10;            }&#10;            current = current.plusDays(1);&#10;        }&#10;        &#10;        return dates;&#10;    }&#10;    &#10;    /**&#10;     * 生成隨機成交量（10,000 ~ 2,000,000）&#10;     */&#10;    private static long generateRandomVolume() {&#10;        return 10000 + random.nextLong(1990000);&#10;    }&#10;    &#10;    /**&#10;     * 生成隨機成交金額（1,000,000 ~ 100,000,000）&#10;     */&#10;    private static long generateRandomAmount() {&#10;        return 1000000 + random.nextLong(99000000);&#10;    }&#10;    &#10;    /**&#10;     * 測試用主方法&#10;     */&#10;    public static void main(String[] args) {&#10;        generateTestData(&quot;src/testdata.csv&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>